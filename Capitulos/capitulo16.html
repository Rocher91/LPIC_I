<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Capítulo 16</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      margin: 0;
      padding: 2rem;
      max-width: 2000px;
      margin: auto;
    }
    h1 {
      color: #333;
      text-align: center;
    }
    p {
      line-height: 1.6;
      color: #444;
    }
    .volver {
      display: block;
      margin-top: 2rem;
      text-align: center;
    }
    .volver a {
      color: #0077cc;
      text-decoration: none;
      font-weight: bold;
    }
    .volver a:hover {
      color: #005999;
    }
  </style>
</head>
<body>
  <h1>Capítulo 16</h1>

  <nav>
    <ul>
      <li><a href="#16-1">15.1 Introducción</a></li>
      <li><a href="#16-2">15.2</a></li>
      <li><a href="#16-3">15.3</a></li>
      <li><a href="#16-4">15.4</a></li>
      <li><a href="#16-5">15.5</a></li>
      <li><a href="#16-6">15.6</a></li>
      <li><a href="#16-7">15.7</a></li>
    </ul>
  </nav> 

  <section id="16-1">
    <h2>16.1 Introducción</h2>
    <p>El arranque (<em>booting</em>) es el proceso de llevar el sistema desde un estado apagado hasta un sistema operativo en ejecución. Es muy importante comprender este proceso para poder solucionar problemas de arranque cuando ocurran y para modificar los estados del sistema llamados <em>runlevels</em> o, en dispositivos con systemd, <em>targets</em>.</p>

    <p>El proceso de arranque ocurre en cuatro etapas principales, algunas de las cuales pueden ser modificadas por los administradores, mientras que en otras basta con estar al tanto de las acciones que tienen lugar:</p>

    <ul>
      <li><strong>Etapa de firmware</strong></li>
      <li><strong>Gestor de arranque (Bootloader)</strong></li>
      <li><strong>Etapa del kernel</strong></li>
      <li><strong>Etapa Init</strong></li>
    </ul>

    <div align="center">
    <img src="ch16_a.png" alt="Descripción de la imagen" width="800" height="300" align="center">
  </div>

  </section>

  <hr>

  <section id="16-2">
  <h2>16.2 Etapa de Firmware</h2>
  <p>La etapa de firmware es la primera en llevarse a cabo después de encender la computadora. En este punto, la computadora tiene energía, pero necesita comenzar a ejecutar algún software que eventualmente permita arrancar por completo un kernel.</p>

  <p>La mayoría del firmware de PC se conoce como <em>Basic Input/Output System (BIOS)</em>. El BIOS está almacenado en la placa base en memoria no volátil, como memoria de solo lectura (ROM) o memoria flash.</p>

  <p>El BIOS tiene tres tareas principales que cumplir como parte de la primera etapa del proceso de arranque:</p>
  <ul>
    <li>Ejecutar una <strong>prueba automática de encendido (POST)</strong> para asegurarse de que el hardware del sistema funcione correctamente. El POST realiza verificaciones básicas en la CPU, la memoria y los periféricos, de manera que errores evidentes, como chips de memoria faltantes o dispositivos de disco defectuosos, se detecten temprano en el ciclo de arranque.</li>
    <li><strong>Enumerar</strong> el hardware disponible, como memoria, discos y dispositivos USB.</li>
    <li>Encontrar la unidad de arranque adecuada entre los dispositivos de almacenamiento disponibles y cargar el <strong>Master Boot Record (MBR)</strong> desde ese dispositivo. El MBR es el primer sector (o 512 bytes) del disco.</li>
  </ul>

  <h3>Considera esto</h3>
  <p>Incluso en sistemas que han reemplazado el BIOS tradicional por la <em>Unified Extensible Firmware Interface (UEFI)</em>, el firmware del sistema aún suele denominarse BIOS. Ambos son firmware: pequeños sistemas operativos embebidos en el hardware que gestionan la interfaz entre el hardware y el sistema operativo que se va a arrancar.</p>

  <p>El BIOS se considera obsoleto porque está limitado al direccionamiento de memoria de 16 bits, puede tener solo un tamaño reducido y arranca leyendo el primer sector de un disco. UEFI, en cambio, utiliza una partición especial en un disco llamada <strong>EFI System Partition</strong> para almacenar el gestor de arranque de un sistema operativo.</p>

  <p>El BIOS y el firmware UEFI se han vuelto más sofisticados con el tiempo. Sin embargo, en la mayoría de los arranques, están allí para realizar los tres pasos principales mencionados arriba, con el fin de llegar a la etapa del gestor de arranque.</p>
  </section>

  <hr>
  <section id="16-3">
  <h2>16.3 Etapa del Gestor de Arranque</h2>
  <p>El <em>Master Boot Record (MBR)</em> contiene una tabla de particiones y una pequeña cantidad de código ejecutable llamado <strong>gestor de arranque de primera etapa</strong>, cuya función es cargar el gestor de arranque de segunda etapa, más completo. El gestor de arranque realiza varias operaciones, pero su tarea principal es cargar el kernel de Linux en memoria y ejecutarlo.</p>

  <p>Si un gestor de arranque puede caber completamente en los primeros 512 bytes del MBR e iniciar el sistema operativo con esa cantidad limitada de código, se considera un <strong>gestor de arranque de una sola etapa</strong>. Una segunda etapa es necesaria cuando el código requerido para inicializar correctamente el sistema e iniciar el sistema operativo no cabe en el MBR. En este caso, el gestor de arranque de primera etapa apunta al de segunda etapa, que puede ser más grande y será el que realmente inicie el sistema operativo. Una vez que esto ocurre, el kernel toma el control del arranque.</p>

  <p>El gestor de arranque más común en las máquinas es el <strong>Grand Unified Bootloader (GRUB)</strong>. La versión más reciente de GRUB soporta arrancar Linux en sistemas con UEFI, la edición interactiva del menú durante el arranque y mucho más.</p>

  <p>Los sistemas UEFI proporcionan a la etapa de firmware mucha más memoria y capacidades, lo que les permite manejar hardware mucho más grande y complejo.</p>

  <h3>Considera esto</h3>
  <p>Fuera de las arquitecturas compatibles con IBM PC, existen otros gestores de arranque que se utilizan. En sistemas Linux que arrancan en hardware Sparc se usa el <strong>Sparc Improved bootLOader (SILO)</strong>, y en hardware PowerPC se usa <strong>Yet Another BOOTloader (YABOOT)</strong>.</p>

  <p>También es posible arrancar desde la red mediante el <strong>Preboot Execution Environment (PXE)</strong>. En PXE, una placa base y tarjeta de red compatibles contienen suficiente inteligencia para obtener una dirección desde la red y usar el protocolo <strong>Trivial File Transfer Protocol (TFTP)</strong> para descargar un gestor de arranque especial desde un servidor.</p>

  <p>Como el gestor de arranque es simplemente software que se encarga de ejecutar un kernel, es posible arrancar múltiples sistemas operativos en diferentes momentos en un mismo equipo, en un proceso conocido como <strong>arranque dual o múltiple</strong>. El kernel que el gestor de arranque intente ejecutar puede ser uno de Linux, una imagen de Microsoft Windows o incluso un CD de arranque.</p>

  <p>El gestor de arranque también puede pasar parámetros al kernel, por ejemplo, para arrancar en modo de mantenimiento o para habilitar o deshabilitar cierto hardware. Esto se hace manipulando la configuración del gestor de arranque. GRUB ofrece una interfaz de línea de comandos bastante potente que permite a un administrador realizar cambios al kernel antes de que arranque, sin necesidad de escribir la configuración en disco.</p>

  <p>Finalmente, el gestor de arranque carga el kernel desde el disco hacia la memoria y transfiere el control. El sistema ya está ejecutando Linux y puede terminar el proceso de arranque.</p>
  </section>
  <hr>
  <section id="16-4">
  <h2>16.4 Etapa del Kernel</h2>
  <p>Ahora que el gestor de arranque ha cargado el kernel en memoria, queda mucho trabajo por hacer antes de poder cargar programas. El kernel debe inicializar los controladores de hardware y montar el <em>filesystem</em> raíz (<code>/</code>) para la siguiente etapa. Estas dos tareas son bastante complicadas porque las facilidades proporcionadas por el BIOS para acceder al hardware son muy limitadas. Por lo tanto, el kernel debe arrancar el sistema en varias fases.</p>

  <p>El kernel en sí está estructurado como un ejecutable regular, salvo que debe ser autónomo. No hay bibliotecas compartidas disponibles en este punto del arranque, por lo que el kernel está vinculado estáticamente; es decir, solo puede depender de la información que ya fue compilada en él en el momento de arranque, y no de bibliotecas externas. Normalmente, el kernel se encuentra en la partición <code>/boot</code>, que en la mayoría de los casos está separada y ubicada cerca del inicio del disco duro. Esta ubicación es importante para ciertas combinaciones de BIOS y gestores de arranque que solo pueden acceder a los primeros 1024 cilindros del disco.</p>

  <p>El directorio <code>/boot</code>, o alternativamente <code>/boot/efi</code>, es uno de los más importantes en el <em>File Hierarchy Standard (FHS)</em>. Los sistemas modernos usan UEFI para especificar la ubicación exacta donde la computadora busca los archivos que necesita para arrancar. En este contexto se puede escuchar el término <em>bootstrap</em>, que se refiere al método por el cual el BIOS localiza y carga la primera parte del sistema operativo cuando la computadora se enciende.</p>

  <p>Si el BIOS no está configurado correctamente, el sistema no podrá cargar sus programas de arranque y el inicio fallará. Este parámetro normalmente se ajusta interrumpiendo la secuencia de arranque al principio (a menudo con la tecla F12 o Esc) y entrando al programa de configuración del BIOS. Para detalles exactos, se deben consultar las instrucciones del fabricante.</p>

  <p>A medida que el kernel fue creciendo en tamaño, los desarrolladores encontraron útil comprimirlo para que encajara en las limitaciones del BIOS. Por eso, el ejecutable del kernel se descomprime a sí mismo al cargarse, lo que dio lugar al nombre <strong>zImage</strong>, donde la letra <em>z</em> hace referencia a la librería de compresión zlib de Unix.</p>

  <p>Con el tiempo, el kernel siguió aumentando y se volvió difícil cargarlo en un solo bloque consecutivo de memoria. Entonces apareció el formato <strong>bzImage</strong>, que permite cargar el kernel en múltiples bloques de memoria, especialmente en memoria alta.</p>

  <h3>Considera esto</h3>
  <p>La <strong>b</strong> en <em>bzImage</em> significa <em>big</em> (grande). No indica que se use bzip2 para la compresión; la compresión sigue siendo con gzip.</p>

  <p>El kernel de Linux debe montar el sistema de archivos raíz para avanzar y hacer el sistema utilizable. Sin embargo, es posible que el sistema de archivos raíz se encuentre en un dispositivo que el kernel no sabe cómo manejar. La solución a esto es el <strong>disco RAM inicial (initrd)</strong>. Los controladores necesarios para continuar el arranque se agrupan en este sistema de archivos almacenado junto al kernel en <code>/boot</code>. El kernel arranca, monta el initrd, carga los controladores que contiene y luego vuelve a montar el sistema de archivos raíz real usando los nuevos controladores. Esto permite que el kernel monte el sistema de archivos raíz en casi cualquier hardware de almacenamiento, incluso a través de una red.</p>

  <p>Durante el arranque, el kernel inicializa el hardware reconocido y pone los dispositivos detectados a disposición del resto del sistema operativo.</p>

  <p>La tarea final del kernel es iniciar el primer proceso del sistema. Normalmente, este proceso tiene un ID de proceso (PID) de 1; en un sistema System V, este proceso se llama <code>init</code>.</p>

  <aside><strong>Nota:</strong> En sistemas con systemd, el archivo <code>/sbin/init</code> es un enlace simbólico a <code>/usr/lib/systemd/systemd</code> para fines de compatibilidad.</aside>

  <p>Para mostrar el primer proceso (<code>init</code>), ejecuta el comando <code>ps</code> con las siguientes opciones no-BSD, que mostrarán todos los procesos del sistema en formato jerárquico:</p>

  <pre><code>sysadmin@localhost:~$ ps -ejH
  PID  PGID   SID TTY          TIME CMD
    1     1     1 ?        00:00:00 init
   32    32    32 ?        00:00:00 rsyslogd
   37    37    37 ?        00:00:00 cron
   39    39    39 ?        00:00:00 sshd
   56    56    56 ?        00:00:00 named
   69     1     1 ?        00:00:00 login
   79    79     1 ?        00:00:00 bash
  676   676     1 ?        00:00:00 ps</code></pre>

  <p>El primer proceso es responsable de gran parte de la operación del sistema en adelante. Para fines de consistencia usamos <code>/sbin/init</code>, recordando que otros sistemas pueden usar systemd en lugar de System V para la gestión de procesos.</p>

  <p>En algunos casos, como en hardware embebido, el proceso <code>init</code> podría ser un <em>shell</em> o un demonio especializado. En cualquier caso, este primer proceso inicia los demonios que usará el resto del sistema y se convierte en el proceso padre de cualquier proceso que quede huérfano. Este proceso persiste durante toda la vida del sistema.</p>
  </section>
  <hr>

  <section id="16-5">
  <h2>16.5 La Etapa Init</h2>
  <p>La etapa <em>init</em> finaliza el proceso de arranque del sistema. Se inicia el primer proceso del sistema operativo (también llamado <code>init</code>). El proceso <code>init</code> tiene tres responsabilidades importantes:</p>

  <ul>
    <li>Continuar el proceso de arranque para que los servicios se inicien, las pantallas de inicio de sesión se muestren y las consolas escuchen.</li>
    <li>Iniciar todos los demás procesos del sistema.</li>
    <li>Adoptar cualquier proceso que se separe de su proceso padre.</li>
  </ul>

  <p>Hasta hace poco, este proceso seguía un diseño establecido con la publicación de <strong>System V de Unix</strong>, a menudo llamado <strong>SysVinit</strong>. El proceso que realmente se ejecuta es el proceso <code>init</code>. Recientemente, han surgido otros programas que compiten con el <code>init</code> tradicional para reemplazarlo, como <strong>Upstart</strong> y <strong>systemd</strong>.</p>

  <p>Si el sistema usa el programa <code>init</code> tradicional, entonces el archivo <code>/etc/inittab</code> se utiliza para determinar qué scripts se ejecutarán para iniciar los servicios que estarán disponibles en el sistema.</p>

  <p>El archivo <code>inittab</code> apunta a otros scripts que hacen el trabajo, normalmente almacenados en el directorio <code>/etc/init.d</code>. Se hablará más sobre estos scripts más adelante, pero en general, cada servicio que ejecuta el sistema tiene un script que puede iniciarlo, detenerlo y reiniciarlo. El proceso <code>init</code> se encarga de ejecutar cada uno de estos scripts según sea necesario para llevar el sistema al estado deseado.</p>

  <p>Si el <code>init</code> tradicional ha sido reemplazado por <strong>Upstart</strong>, los scripts en el directorio <code>/etc/init</code> se usan para completar la inicialización del sistema.</p>

  <p>Si el <code>init</code> tradicional ha sido reemplazado por <strong>Systemd</strong>, entonces los archivos en el directorio <code>/etc/systemd</code> se usan para iniciar y ejecutar el sistema.</p>

  <p>Incluso si tu sistema usa <em>Systemd</em> o <em>Upstart</em> como reemplazo del proceso <code>init</code> tradicional, ambos reemplazos usan un ejecutable llamado <code>init</code> en la ruta <code>/sbin/init</code>. Esto es para mantener la compatibilidad con muchos procesos heredados. Así que, aunque el comportamiento de <em>Systemd</em> y <em>Upstart</em> sea diferente, ambos comparten características similares al <code>init</code> tradicional.</p>

  <p>Aunque tu sistema solo usará una de estas tecnologías de arranque, es importante entender las tres. Por ejemplo, mientras que tu sistema actual puede usar <strong>SysVinit</strong>, podrías encontrarte trabajando en una distribución diferente en el futuro que use <strong>Upstart</strong>. En cualquier caso, los tres procesos son temas evaluables en los exámenes LPIC.</p>
  </section>
  <hr>

  <section id="16-5-1">
  <h2>16.5.1 initramfs</h2>
  <p>Introducido en la época del kernel 2.6, el <strong>initramfs</strong> es el sistema de archivos raíz inicial al que un sistema Linux suele tener acceso. Piensa en él como un sistema de archivos temporal de “arranque” que proporciona los archivos y controladores necesarios para iniciar el sistema de archivos raíz real y continuar con el arranque del sistema.</p>

  <p>El sistema de archivos initramfs es una solución al problema del “huevo y la gallina”: algo no puede ocurrir antes que lo otro, y viceversa, infinitamente. Por ejemplo, el kernel puede requerir un controlador de disco para acceder a un disco, pero ese controlador está ubicado en el mismo disco al que quiere acceder. Las dos soluciones a este dilema son: 1) usar <code>initramfs</code> o 2) compilar el controlador dentro del kernel.</p>

  <p>Sin embargo, compilar el controlador en el kernel tiene sus propios problemas, entre ellos que se considera poco elegante, hace que el kernel sea más grande y tarde más en cargarse. El problema se agrava si el controlador necesita actualizarse, ya que está compilado directamente dentro del kernel.</p>

  <p>La situación se vuelve aún más compleja cuando el sistema tiene dispositivos o sistemas de archivos que requieren que se ejecute un programa en espacio de usuario, o una interacción del usuario con dicho programa, para cargarse. Como la ubicación original de estos programas está en el disco que necesitan habilitar para ser cargados, se convierte en un problema circular.</p>

  <div class="note">
    <p><strong>Ten en cuenta:</strong> El espacio de usuario y el espacio del kernel son las dos regiones de la RAM que administra el kernel de Linux. Los programas que se ejecutan en el espacio del kernel tienen acceso a todas las regiones de RAM, y cuando un programa solicita acceso a algo, el kernel lo gestiona de manera segura y devuelve la información al programa. El espacio de usuario tiene restricciones: los programas allí no pueden acceder directamente a toda la RAM del kernel ni a la usada por otros programas; todos los accesos deben hacerse mediante llamadas al sistema gestionadas por el kernel.</p>
  </div>

  <p>El <code>initramfs</code> es un archivo <em>cpio</em>, que puede insertarse en un punto específico del kernel. El kernel desempaqueta su contenido en un disco RAM (<em>RAM disk</em>) para su acceso. Detecta que el archivo cpio contiene datos, crea un sistema de archivos temporal llamado <code>tmpfs</code> y desempaqueta allí el contenido del archivo cpio.</p>

  <p>Después de ser desempaquetado, el kernel ejecuta el script <code>init</code> incluido en el sistema de archivos raíz del disco RAM de <code>initramfs</code>, el cual carga los controladores necesarios y ejecuta los programas de espacio de usuario requeridos para montar el sistema de archivos raíz real (un caso típico sería LVM, RAID o sistemas de archivos cifrados).</p>

  <p>Una vez que el script <code>init</code> del <code>initramfs</code> termina de cargar los controladores apropiados y montar el sistema de archivos raíz real, transfiere el control al programa binario <code>/sbin/init</code> del sistema de archivos raíz real para continuar con la inicialización del sistema.</p>

  <p>Cuando el kernel ha terminado de arrancar y el sistema de archivos raíz real está montado, la memoria asignada al disco RAM inicial puede liberarse. Esta es la principal ventaja de colocar los controladores en <code>initramfs</code> en lugar de compilarlos dentro del kernel: si un controlador en <code>initramfs</code> no se necesita, no seguirá ocupando RAM después de la etapa de arranque.</p>

  <p>El <code>initramfs</code> se construye inicialmente con la utilidad <code>mkinitramfs</code> o se actualiza con <code>update-initramfs</code>, que también puede crear un nuevo <code>initramfs</code>. Estos comandos recopilan los archivos y utilidades de espacio de usuario necesarios desde sus ubicaciones instaladas hacia un directorio temporal, se archivan con <em>cpio</em> y luego se comprimen con <em>gzip</em>.</p>

  <div class="note">
    <p><strong>Nota:</strong> La creación de un <code>initramfs</code> está fuera del alcance de los objetivos LPIC y, por lo tanto, de este curso.</p>
  </div>
  </section>
  <hr>

  <section id="16-6">
  <h2>16.6 Mensajes del Kernel</h2>
  <p>El comando <code>dmesg</code> puede ejecutarse después de arrancar el sistema para ver los mensajes generados por el kernel durante el arranque. Esto es útil cuando el sistema no parece arrancar correctamente; los mensajes mostrados pueden ayudar a un administrador a diagnosticar problemas en el proceso de arranque.</p>

  <p>Los mensajes del kernel se almacenan en un <em>ring buffer</em> de tamaño limitado; por lo tanto, los mensajes generados durante el arranque pueden sobrescribirse más tarde a medida que el búfer se llena. Es posible que algunos mensajes del kernel generados en el arranque se almacenen en el archivo <code>/var/log/dmesg</code>. Cada vez que el sistema arranca, el archivo <code>/var/log/dmesg</code> se sobrescribe con los mensajes generados durante el proceso de arranque.</p>

  <p>Es común ejecutar el comando <code>dmesg</code> al conectar un nuevo dispositivo al sistema. Esto permite al administrador ver cómo el kernel gestionó el nuevo dispositivo y, normalmente, qué nombre de ruta se le ha asignado.</p>

  <pre>
  sysadmin@localhost:~$ dmesg | tail -n 20
  [5974251.345037] br0: port 2(veth2) entered forwarding state
  [5974264.554578] br0: port 1(vxlan1) entered forwarding state
  [5974266.346778] br0: port 2(veth2) entered forwarding state
  [5974312.446398] br0: renamed from ov-0044a8-d8912
  [5974312.686393] vxlan1: renamed from vx-0044a8-d8912
  [5974312.744241] device vxlan1 entered promiscuous mode
  [5974312.807735] br0: port 1(vxlan1) entered forwarding state
  [5974312.810025] br0: port 1(vxlan1) entered forwarding state
  [5974313.419196] veth2: renamed from vethe3e05ea
  [5974313.475445] device veth2 entered promiscuous mode
  [5974313.513109] IPv6: ADDRCONF(NETDEV_UP): veth2: link is not ready
  [5974313.513114] br0: port 2(veth2) entered forwarding state
  [5974313.515380] br0: port 2(veth2) entered forwarding state
  [5974313.788114] br0: port 2(veth2) entered disabled state
  [5974314.346447] eth0: renamed from veth09f186c
  [5974314.439047] IPv6: ADDRCONF(NETDEV_CHANGE): veth2: link becomes ready
  [5974314.447452] br0: port 2(veth2) entered forwarding state
  [5974314.450219] br0: port 2(veth2) entered forwarding state
  [5974327.857296] br0: port 1(vxlan1) entered forwarding state
  [5974329.457467] br0: port 2(veth2) entered forwarding state
  </pre>
  </section>
  <hr>
  <section id="16-7">
  <h2>16.7 El archivo /var/log/messages</h2>
  <p>Los mensajes del kernel y otros mensajes relacionados con el sistema suelen almacenarse en el archivo <code>/var/log/messages</code>. Este archivo, considerado el archivo de registro principal, en algunas distribuciones se denomina <code>/var/log/syslog</code>. El contenido del archivo <code>/var/log/messages</code> se verá de la siguiente forma:</p>

  <div class="note">
    <p><strong>Nota:</strong> Los siguientes ejemplos representan un sistema distinto de esta máquina virtual. El ejemplo puede no coincidir con la salida de nuestro entorno virtual.</p>
  </div>

  <pre>
[root@centos ~]# tail /var/log/messages
May 27 23:01:59 localhost named[1007]:     validating @0x7f0d34433a50:  .
DNSKEY:  unable to find a DNSKEY which verifies the DNSKEY RRset and also
matches a trusted key for '.'
May 27 23:01:59 localhost named[1007]:     validating @0x7f0d34433a50:  .
DNSKEY: please check the 'trusted-keys' for '.' In named.conf .
May 27 23:01:59 localhost named[1007]:   error (network unreachable)
resolving 'dlv.isc.org/DNSKEY/IN' : 2001:500:e::1#53
...
  </pre>

  <p>Tradicionalmente, el archivo de registro principal se actualiza con nuevas entradas mediante la combinación de los demonios <code>syslogd</code> y <code>klogd</code>. Entre sus reemplazos se incluyen los demonios <code>rsyslogd</code> y <code>syslog-ng</code>.</p>

  <div class="note">
    <p><strong>Nota:</strong> Un <em>demonio</em> es un proceso que se ejecuta automáticamente en segundo plano. Los demonios de registro del sistema, como <code>syslogd</code>, <code>klogd</code>, <code>rsyslogd</code> y otros, son procesos en segundo plano que envían mensajes del sistema a los archivos de registro.</p>
    <p>Como es habitual en Linux, la letra <strong>“d”</strong> en el nombre del proceso indica que es un demonio. Por ejemplo, <code>syslogd</code> es el demonio que admite el protocolo de registro <em>syslog</em>.</p>
  </div>

  <p>En un sistema basado en <strong>systemd</strong>, el demonio <code>journald</code> es el mecanismo de registro, y se configura mediante el archivo <code>/etc/systemd/journald.conf</code>. El formato de los registros de <code>journald</code> es binario, a diferencia de los demonios de registro más tradicionales. Para ver la configuración de <code>journald</code>, se puede usar:</p>

  <pre>
[root@centos ~]# cat /etc/systemd/journald.conf
#Seal=yes
#SplitMode=uid
#SyncIntervalSec=5m
#RateLimitInterval=30s
#RateLimitBurst=1000
...
  </pre>

  <p>En un sistema basado en <code>systemd</code>, el archivo de registro principal se encuentra en <code>/var/log/journal</code> para registros persistentes o en <code>/run/log/journal</code> para registros en RAM (no persistentes).</p>

  <p>Los archivos binarios de <code>journald</code> se visualizan con el comando <code>journalctl</code>. Por ejemplo, para mostrar mensajes relacionados con el arranque más reciente, similar a <code>dmesg</code>, se usa:</p>

  <pre>
[root@centos ~]# journalctl -b
-- Logs begin at Tue 2019-06-04 16:21:58 UTC, end at Tue 2019-06-04 16:26:25 UTC
Jun 04 16:21:58 centos kernel: Initializing cgroup subsys cpuset
Jun 04 16:21:58 centos kernel: Initializing cgroup subsys cpu
...
  </pre>

  <p>Aunque los registros binarios generados por <code>systemd</code> a través de <code>journald</code> no son fáciles de leer con comandos estándar como <code>cat</code> o <code>less</code>, el comando <code>journalctl</code> permite acceder a ellos de forma eficiente. El nuevo formato de datos ofrece ventajas importantes que compensan esta diferencia.</p>

  <p>En sistemas <strong>System V</strong>, el archivo principal de registros (<code>/var/log/messages</code>) es un archivo de texto que se puede ver con los comandos tradicionales de visualización de texto. Tanto en formato binario como de texto, los archivos de registro son útiles para analizar por qué algunos servicios no arrancan correctamente o por qué ciertos dispositivos no funcionan, ya que el kernel agrega entradas al archivo cuando detecta dispositivos o carga módulos y controladores.</p>

  <p>Aunque <code>/var/log/messages</code> se considera el archivo principal de registros, existen otros en la carpeta <code>/var/log</code> que pueden ser útiles al solucionar problemas de servicios del sistema. Por ejemplo, el demonio del servidor web Apache (<code>httpd</code>) administra sus propios registros en <code>/var/log/httpd/error_log</code>. Tradicionalmente, todos los archivos de registro se almacenan en <code>/var/log</code>.</p>
  </section>
  <hr>
  




 





  <hr>
  <div class="volver">
    <a href="../index.html">← Volver al índice</a>
  </div>

</body>
</html>
