<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Capítulo 1X</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      margin: 0;
      padding: 2rem;
      max-width: 800px;
      margin: auto;
    }
    h1 {
      color: #333;
      text-align: center;
    }
    p {
      line-height: 1.6;
      color: #444;
    }
    .volver {
      display: block;
      margin-top: 2rem;
      text-align: center;
    }
    .volver a {
      color: #0077cc;
      text-decoration: none;
      font-weight: bold;
    }
    .volver a:hover {
      color: #005999;
    }
  </style>
</head>
<body>
  <h1>Capítulo 1X</h1>

  <nav>
    <ul>
      <li><a href="#1X-1">15.1 Introducción</a></li>
      <li><a href="#1X-2">15.2</a></li>
      <li><a href="#1X-3">15.3</a></li>
      <li><a href="#1X-4">15.4</a></li>
      <li><a href="#1X-5">15.5</a></li>
      <li><a href="#1X-6">15.6</a></li>
      <li><a href="#1X-7">15.7</a></li>
      <li><a href="#1X-8">15.8</a></li>
      <li><a href="#1X-9">15.9</a></li>
      <li><a href="#1X-10">15.10</a></li>
    </ul>
  </nav> 

  <section id="21-1">
  <h2>21.1 Introducción</h2>
  <p>Linux trata casi todo como un archivo, lo que hace que la función que realiza el sistema de archivos sea particularmente importante. El sistema de archivos es una estructura en forma de árbol, con directorios que contienen subdirectorios y archivos. A diferencia de otros sistemas operativos con los que puedes estar familiarizado, la estructura lógica de directorios de Linux puede abarcar múltiples discos y particiones, organizados bajo un único directorio raíz. En lugar de manipular letras de unidad, el administrador "injerta" o monta nuevas particiones, cada una con su propio sistema de archivos, sobre directorios existentes para dar la ilusión de una única y gran unidad.</p>
  <p>Recordemos los tres pasos en el proceso de creación y uso de sistemas de archivos:</p>
  <ol>
    <li>Dividir el disco duro en particiones.</li>
    <li>Formatear cada partición con un sistema de archivos.</li>
    <li>Montar las particiones formateadas en el árbol de directorios de un sistema de archivos existente.</li>
  </ol>
  <p>Este capítulo se centrará en el paso final de montar la partición formateada.</p>
  </section>
  <hr>

  <section id="21-2">
  <h2>21.2 Visualización de sistemas de archivos montados</h2>
  <p>El montaje de particiones y la verificación de montajes existentes se realiza con el comando <code>mount</code>. Cuando se invoca sin argumentos, el comando <code>mount</code> muestra los dispositivos actualmente montados. Esto puede ser realizado por usuarios regulares, no solo por el usuario root.</p>
  <p>La salida del comando puede ser similar a la siguiente:</p>
  <div class="note">
    <p><strong>Nota:</strong> El siguiente ejemplo podría no coincidir con la salida de nuestro entorno virtual.</p>
  </div>
  <pre><code>sysadmin@localhost:~$ mount
/dev/sda2 on / type ext4 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
tmpfs on /dev/shm type tmpfs (rw)
/dev/sda1 on /boot type ext4 (rw)
/dev/sda5 on /home type ext4 (rw)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs</code></pre>
  <p>El formato general de esta salida es:</p>
  <p><code>DESCRIPCIÓN DE LA FUENTE on PUNTO DE MONTAJE type TIPO DE SISTEMA DE ARCHIVOS (OPCIONES)</code></p>

  <h3>Descripción de la fuente</h3>
  <pre><code>/dev/sda5 on /home type ext4 (rw)

proc on /proc type proc (rw)</code></pre>
  <p>Cada sistema de archivos montado proviene de una fuente, ya sea un dispositivo que representa un disco, una ubicación de red para un sistema de archivos de red o una etiqueta que indica un pseudo-sistema de archivos. Esta última clase (que incluye <code>proc</code>, <code>sysfs</code>, <code>devpts</code>, <code>tmpfs</code>, <code>none</code> y <code>sunrpc</code> en la salida anterior) es la forma en que el kernel de Linux comparte información con el sistema de archivos real. Por ejemplo, el sistema de archivos <code>proc</code> expone la lista de procesos y la configuración del sistema como un conjunto de archivos que se pueden leer y escribir.</p>

  <h3>Punto de montaje</h3>
  <pre><code>/dev/sda2 on / type ext4 (rw)
/dev/sda5 on /home type ext4 (rw)</code></pre>
  <p>El punto de montaje muestra dónde se puede encontrar la fuente en el sistema de archivos. La salida anterior indica que el sistema de archivos raíz <code>/</code> se sirve desde la partición <code>/dev/sda2</code>, pero los archivos en el directorio <code>/home</code> se almacenan en la partición <code>/dev/sda5</code>.</p>

  <h3>Tipo de sistema de archivos</h3>
  <pre><code>/dev/sda5 on /home type ext4 (rw)
proc on /proc type proc (rw)</code></pre>
  <p>Cada sistema de archivos tiene un tipo, que le dice al kernel cómo trabajar con los datos contenidos en el dispositivo. Para sistemas de archivos reales como <code>xfs</code>, <code>ext4</code> y <code>reiserfs</code>, esto relaciona los bloques almacenados en el disco con los archivos y directorios que ves. Para sistemas de archivos de red como <code>nfs</code>, esto traduce las llamadas de red y los paquetes enviados y recibidos en lecturas y escrituras de disco. Para los pseudo-sistemas de archivos, el tipo de sistema de archivos describe qué tipo de recursos se exponen.</p>

  <div class="consider-this">
    <h3>Considera esto</h3>
    <p>La mayoría de los sistemas operativos permiten acceder a archivos en otra computadora en lugar de requerir que los archivos se copien de un lado a otro. Este concepto a menudo se conoce como un recurso compartido de red, o simplemente un "file share". Con muchos sistemas operativos, se accede a un archivo remoto de manera diferente a un archivo local, como tener que especificar una ruta de red cada vez que se accede al archivo.</p>
    <p>UNIX hace un uso intensivo de abstracciones para facilitar el trabajo del usuario. En lugar de presentar un recurso compartido de archivos remoto y un disco duro local de manera diferente, el kernel se encarga de los detalles y presenta una interfaz estándar. Así, un volumen de red (unidad, partición o carpeta) de otra computadora se puede montar de manera similar a una unidad local. Las únicas diferencias son el tiempo para acceder al recurso y la ubicación: los volúmenes de red utilizan una dirección IP y una ruta, mientras que los volúmenes locales simplemente usan una ruta a un dispositivo para un volumen local. Una vez que se monta un volumen, parece cualquier otra parte del disco.</p>
    <p>Otra abstracción es el concepto de pseudo-sistema de archivos. Un pseudo-sistema de archivos no está contenido en un disco real; es una vista jerárquica de los datos del kernel. Por ejemplo, el pseudo-sistema de archivos <code>proc</code> expone cada proceso como un directorio de archivos y subdirectorios, donde cada archivo contiene diversa información, desde el entorno del proceso hasta la lista de archivos que tiene abiertos. El pseudo-sistema de archivos <code>proc</code> también tiene archivos y directorios que corresponden a varias opciones, como los tamaños de búfer de red que se pueden leer y escribir.</p>
    <p>Presentar la información del sistema como un sistema de archivos le da al administrador una interfaz familiar que es fácil de usar y scriptar.</p>
  </div>

  <h3>Opciones</h3>
  <pre><code>/dev/sda5 on /home type ext4 (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)</code></pre>
  <p>Cada sistema de archivos también tiene opciones. Algunas opciones, como la opción de lectura/escritura <code>rw</code> y la opción de solo lectura <code>ro</code>, son bastante universales. Algunos sistemas de archivos tienen opciones que corresponden a elementos específicos, como los parámetros de tiempo de espera de red para un sistema de archivos de red o los parámetros de registro para un sistema de archivos con registro.</p>
  <p>Los administradores generalmente trabajan con unidades de disco y sistemas de archivos de red, dejando los pseudo-sistemas de archivos para que la distribución los configure y administre. Los discos pueden adoptar muchas formas, como particiones de disco individuales, discos lógicos compuestos por múltiples discos (como LVM), o incluso otro hardware que se presenta como un disco (como RAID).</p>
  <p>Otro método para obtener información sobre sistemas de archivos es usando el comando <code>lsblk</code>. El comando <code>lsblk</code> lista información sobre dispositivos de bloque, ya sea todos los disponibles con la opción <code>-a</code>, o la salida se puede adaptar con varias otras opciones, como la opción <code>-f</code>, que muestra información sobre los sistemas de archivos disponibles.</p>
  <pre><code>sysadmin@localhost:/$ lsblk -a
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
loop0    7:0    0        0 loop
loop1    7:1    0        0 loop
loop2    7:2    0        0 loop
loop3    7:3    0        0 loop
loop4    7:4    0        0 loop
loop5    7:5    0        0 loop
loop6    7:6    0        0 loop
loop7    7:7    0        0 loop
sda      8:0    0  3.7T  0 disk
|-sda1   8:1    0  512M  0 part
|-sda2   8:2    0  3.5T  0 part /etc/hosts
`-sda3   8:3    0  128G  0 part [SWAP]
sdb      8:16   1        0 disk
sdc      8:32   1        0 disk
sr0     11:0    1 1024M  0 rom
sr1     11:1    1 1024M  0 rom
sysadmin@localhost:/$ lsblk -f
NAME   FSTYPE LABEL UUID MOUNTPOINT
sda
|-sda1
|-sda2                   /etc/hosts
`-sda3                   [SWAP]
sr0
sr1                            </code></pre>
  </section>
  <hr>

  <section id="21-3">
  <h2>21.3 Montaje manual de sistemas de archivos</h2>
  <p>Para montar correctamente un sistema de archivos, se deben proporcionar al menos dos parámetros al comando <code>mount</code>: el identificador del sistema de archivos y la ruta del directorio donde montarlo. Si no se necesitan otras opciones, el comando <code>mount</code> montará el sistema de archivos en el punto de montaje del directorio especificado.</p>

  <div class="important">
    <p><strong>Importante:</strong> A menos que se configure previamente en el archivo <code>/etc/fstab</code>, el montaje requiere acceso de usuario root.</p>
  </div>

  <div class="note">
    <p><strong>Nota:</strong> Los siguientes ejemplos podrían no coincidir con la salida de nuestro entorno virtual.</p>
  </div>
  <pre><code>root@localhost:~# mount /dev/sdb1 /mnt</code></pre>
  <p>El primer paso para montar un sistema de archivos es crear un directorio que sirva como punto de montaje. Alternativamente, se pueden usar los directorios <code>/mnt</code> y <code>/media</code>, que suelen existir por defecto en la mayoría de las distribuciones de Linux para este propósito. Los directorios <code>/mnt</code> y <code>/media</code> se utilizan típicamente solo para montar un recurso temporal, como medios extraíbles, incluyendo unidades USB y discos ópticos. Algunas distribuciones orientadas a escritorios montarán automáticamente los dispositivos extraíbles bajo el directorio <code>/media/USERNAME/DEVICENAME</code>.</p>
  <p>La forma más sencilla del comando <code>mount</code> manual se muestra arriba. En esta situación, el kernel de Linux entiende que <code>/dev/sdb1</code> es un sistema de archivos e incluso puede detectar qué tipo de sistema de archivos hay en el disco. Si el sistema de archivos no se puede detectar, entonces usa la opción <code>-t</code> para indicar el tipo de sistema de archivos:</p>
  <pre><code>root@localhost:~# mount -t iso9660 /dev/scd0 /mnt</code></pre>
  <p>Este último comando monta un dispositivo llamado <code>/dev/scd0</code> en <code>/mnt</code> y le dice al kernel que use el sistema de archivos <code>iso9660</code>, que es para dispositivos CD y DVD. Si es necesario indicarle al kernel qué tipo de sistema de archivos se está utilizando, esto debería ser una señal de que algo anda mal, ya que la autodetección es generalmente confiable.</p>
  <p>Cuando se monta un sistema de archivos, se utilizan las opciones predeterminadas para ese sistema de archivos. La opción <code>-o</code> se puede usar para especificar opciones de montaje alternativas desde la línea de comandos. Algunas opciones de montaje solo se usan cuando se monta un sistema de archivos manualmente, mientras que otras se usan comúnmente cuando se monta un sistema de archivos automáticamente.</p>
  <p>Para montar un sistema de archivos de solo lectura, pasa la opción <code>ro</code>, como:</p>
  <pre><code>root@localhost:~# mount /dev/sdb2 /opt -o ro</code></pre>

  <div class="consider-this">
    <h3>Considera esto</h3>
    <p>Montar un sistema de archivos en un directorio que ya contiene archivos los dejará temporalmente inaccesibles. Por lo tanto, ten cuidado de montar en directorios que se sepa que están vacíos.</p>
    <p>Una vez que un sistema de archivos está montado en un directorio, solo el contenido de ese sistema de archivos será visible. Lo que era previamente visible en un directorio no ha desaparecido, sino que se volverá visible solo después de que se desmonte el nuevo sistema de archivos.</p>
    <p>Por ejemplo, considera la situación en la que el directorio <code>/data</code> ya contiene archivos y luego se usa como punto de montaje:</p>
    <pre><code>root@localhost:~# ls /data
file1 file2
root@localhost:~# mount /dev/sda3 /data
root@localhost:~# ls /data
file3 file4</code></pre>
    <p>Parece que <code>file1</code> y <code>file2</code> fueron eliminados, pero solo están ocultos. Si el sistema de archivos se desmontara, estos archivos reaparecerían:</p>
    <pre><code>root@localhost:~# ls /data
file3 file4
root@localhost:~# umount /data
root@localhost:~# ls /data
file1 file2</code></pre>
  </div>
  </section>
  <hr>

  <section id="21-4">
  <h2>21.4 Desmontaje manual de sistemas de archivos</h2>
  <p>Para maximizar el rendimiento, Linux mantiene partes del sistema de archivos en la memoria. Si se retiraran medios, como dispositivos USB, antes de que se vaciaran esos búferes de memoria, es posible que algunos datos no se escribieran en el disco. Esto se conoce como un desmontaje "sucio". Esto puede resultar en pérdida de datos o incluso corrupción del sistema de archivos. El desmontaje es el procedimiento utilizado para vaciar todos los búferes y hacer que el disco sea seguro de retirar.</p>
  <p>Para desmontar un sistema de archivos, usa el comando <code>umount</code> con el sistema de archivos o el directorio como argumento. Por ejemplo, para desmontar el directorio <code>/mnt</code> que se montó previamente, ejecuta el siguiente comando:</p>

  <div class="note">
    <p><strong>Nota:</strong> Los siguientes ejemplos podrían no coincidir con la salida de nuestro entorno virtual.</p>
  </div>
  <pre><code>root@localhost:~# umount /mnt</code></pre>
  <p>Dado que el sistema de archivos <code>/dev/sdb1</code> se montó bajo el directorio <code>/mnt</code>, el siguiente comando también habría funcionado:</p>
  <pre><code>root@localhost:~# umount /dev/sdb1</code></pre>
  <p>Hay algunas instancias en las que el comando <code>umount</code> no logrará desmontar un sistema de archivos:</p>
  <ul>
    <li>Hay un archivo abierto que se encuentra dentro del sistema de archivos. El término "abierto" significa en uso por un programa. Por ejemplo, si el archivo estuviera siendo editado por un editor de texto como el editor <code>vi</code>, se consideraría abierto.</li>
    <li>Hay un archivo ejecutable en ejecución que se encuentra dentro del sistema de archivos.</li>
    <li>Un usuario tiene un directorio dentro del sistema de archivos como su directorio de trabajo actual.</li>
  </ul>
  <p>Cuando el comando <code>umount</code> no logra desmontar un sistema de archivos, normalmente informará que el dispositivo está ocupado:</p>
  <pre><code>root@localhost:~# umount /mnt
umount: /mnt: device is busy.
	(En algunos casos, información útil sobre los procesos que usan
	 el dispositivo se encuentra con lsof(8) o fuser(1))</code></pre>
  <p>Para determinar qué está haciendo que el sistema de archivos esté ocupado, usa los comandos <code>lsof</code> o <code>fuser</code> como se sugiere en la salida del ejemplo anterior.</p>
  <p>La salida del comando <code>lsof</code> es la lista de todos los archivos abiertos en el sistema operativo, que fácilmente pueden sumar miles. Por lo tanto, es importante filtrar la salida del comando <code>lsof</code> para encontrar el archivo abierto correcto. Una buena manera de hacerlo es redirigir la salida del comando <code>lsof</code> al comando <code>grep</code>. Usa el comando <code>grep</code> para encontrar el sistema de archivos que debe desmontarse. Por ejemplo, si el directorio <code>/mnt</code> estuviera ocupado, el usuario root puede ejecutar el siguiente comando desde el directorio <code>/mnt</code>:</p>
  <pre><code>root@localhost:/mnt# lsof | grep /mnt
bash      2577      root  cwd       DIR        8,1     1024          2 /mnt
lsof      2631      root  cwd       DIR        8,1     1024          2 /mnt
grep      2632      root  cwd       DIR        8,1     1024          2 /mnt
lsof      2633      root  cwd       DIR        8,1     1024          2 /mnt</code></pre>
  <p>Las tres primeras columnas son las más útiles: el nombre del proceso, el ID del proceso y el usuario que ejecuta el proceso. Usando el ID del proceso junto con el comando <code>kill</code>, un administrador de sistemas puede terminar los procesos que pueden estar manteniendo el directorio ocupado. Sin embargo, ten mucho cuidado al eliminar procesos que tienen archivos abiertos para escritura, ya que esto puede dañar archivos o directorios dentro de un sistema de archivos.</p>
  <p>El comando <code>fuser</code> proporciona una salida mucho más concisa e indicará si un archivo está abierto para escritura. Incluso es capaz de terminar procesos, de manera muy similar al comando <code>kill</code>.</p>
  <p>La opción <code>-v</code> del comando <code>fuser</code> produce una salida ligeramente mayor, incluyendo el nombre del usuario que está ejecutando el proceso y un código que indica la forma en que un proceso está usando el directorio. Por ejemplo, si se intenta desmontar el directorio <code>/mnt</code> sin éxito, intenta ejecutar el siguiente comando <code>fuser</code>:</p>
  <pre><code>root@localhost:~# fuser -v /mnt
                     USER        PID ACCESS COMMAND
/mnt:                root       2529 ..c.. bash</code></pre>
  <p>En este caso, el proceso que mantiene ocupado el directorio <code>/mnt</code> está siendo ejecutado por el usuario root. El ID del proceso es 2529, el acceso <code>c</code> indica que el proceso está usando el directorio como su directorio actual. El proceso en sí es el shell Bash.</p>
  <p>Los códigos de acceso que podría informar el comando <code>fuser</code> son:</p>
  <table>
    <thead>
      <tr>
        <th>Código de Acceso</th>
        <th>Significado</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>c</code></td>
        <td>El proceso está usando el punto de montaje o un subdirectorio como su directorio actual.</td>
      </tr>
      <tr>
        <td><code>e</code></td>
        <td>El proceso es un archivo ejecutable que reside en la estructura del punto de montaje.</td>
      </tr>
      <tr>
        <td><code>f</code></td>
        <td>El proceso tiene un archivo abierto de la estructura del punto de montaje.</td>
      </tr>
      <tr>
        <td><code>F</code></td>
        <td>El proceso tiene un archivo abierto de la estructura del punto de montaje en el que está escribiendo.</td>
      </tr>
      <tr>
        <td><code>r</code></td>
        <td>El proceso está usando el punto de montaje como directorio raíz.</td>
      </tr>
      <tr>
        <td><code>m</code></td>
        <td>El proceso es un archivo <code>mmap</code>'eado o una biblioteca compartida.</td>
      </tr>
    </tbody>
  </table>
  <p>Si el proceso tiene un archivo abierto para escritura o el punto de montaje es un directorio raíz, no es aconsejable eliminar ese proceso. De lo contrario, para terminar el proceso, ejecuta el siguiente comando:</p>
  <pre><code>root@localhost:~# fuser -k /mnt</code></pre>
  <p>Al igual que con el comando <code>kill</code>, la señal predeterminada enviada por el comando <code>fuser</code> es la señal <code>TERM</code>. Usa el comando <code>fuser -l</code> para listar las señales que se pueden usar:</p>
  <pre><code>root@localhost:~# fuser -l
HUP INT QUIT ILL TRAP ABRT IOT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH IO PWR SYS</code></pre>
  <p>Estas son las mismas señales que están disponibles para el comando <code>kill</code>. Para enviar una señal específica con el comando <code>fuser</code>, coloca un guion delante del nombre de la señal. Por ejemplo, para finalizar un proceso persistente que mantiene ocupado el directorio <code>/mnt</code>, ejecuta el siguiente comando:</p>
  <pre><code>root@localhost:~# fuser -k -KILL /mnt</code></pre>
  <p>Una vez que el proceso ha sido terminado, debería ser posible ejecutar el comando <code>umount</code> para desmontar el sistema de archivos.</p>

  <div class="consider-this">
    <h3>Considera esto</h3>
    <p>Al igual que con el comando <code>kill</code>, el comando <code>fuser</code> debe ejecutarse con privilegios de root al intentar administrar un proceso que no pertenece al usuario actual.</p>
    <p>El comando <code>fuser</code> está diseñado para detener procesos para que un sistema de archivos pueda ser desmontado. Debido a que los sistemas de archivos generalmente requieren privilegios de root para desmontarse, parecería inusual que un usuario normal ejecutara los comandos <code>fuser</code> o <code>umount</code>.</p>
    <p>Sin embargo, los medios extraíbles, como los dongles USB y los dispositivos ópticos, normalmente pueden ser desmontados por usuarios normales. Como resultado, saber cómo funciona el comando <code>fuser</code> puede ser útil para los usuarios normales, así como para los administradores.</p>
  </div>
  </section>
  <hr>

  <section id="21-5">
  <h2>21.5 Montaje automático de sistemas de archivos al iniciar</h2>
  <p>El montaje manual de sistemas de archivos con el comando <code>mount</code> resulta en un montaje no persistente. Si el sistema se reinicia, el sistema de archivos debe montarse nuevamente para ser accedido. Lo mismo ocurre con la activación de dispositivos swap con el comando <code>swapon</code>.</p>
  <p>El archivo <code>/etc/fstab</code> se utiliza para configurar qué sistemas de archivos se montarán automáticamente al iniciar. También se puede usar para activar dispositivos swap automáticamente. Podría ser útil pensar en este archivo como la tabla de sistemas de archivos (<em>filesystem table</em>) para recordar su nombre. Para aquellos familiarizados con el montaje manual de un sistema de archivos, el formato del archivo debería tener sentido.</p>
  <p>Se requieren privilegios de root para realizar cambios en el archivo <code>/etc/fstab</code>. Cualquier cambio realizado en este archivo debe hacerse con cuidado, ya que los errores pueden impedir que el sistema arranque normalmente.</p>
  <p>De hecho, sería una excelente idea crear una copia de seguridad del archivo <code>/etc/fstab</code> antes de realizar cambios. En caso de desastre, el archivo original se puede restaurar copiando la copia de seguridad al archivo <code>/etc/fstab</code> utilizando la recuperación de un disco en vivo. Para hacer una copia de seguridad, como usuario root, ejecuta un comando como el siguiente:</p>
  <pre><code>root@localhost:~# cp /etc/fstab /etc/fstab.backup</code></pre>
  <p>Un sistema con tres particiones de sistema de archivos y una partición swap podría tener un archivo <code>/etc/fstab</code> con el siguiente aspecto:</p>
  <pre><code>#
# /etc/fstab
# Creado por anaconda el vie 17 ene 10:31:51 2014
#
# Sistemas de archivos accesibles, por referencia, se mantienen bajo '/dev/disk'
# Ver páginas de manual fstab(5), findfs(8), mount(8) y/o blkid(8) para más info
#
UUID=3db6ba40-67d2-403d-9c0a-9a901697cd8d /      ext4    defaults        1 1
UUID=09d641d5-bc5a-4065-8d80-8ae797dfa7f3 /boot  ext4    defaults        1 2
UUID=5ee634a5-c360-4211-a41b-9aa40d78a804 /home  ext4    defaults        1 2
UUID=34819281-65e3-4c78-ba2d-16952684c9cb swap   swap    defaults        0 0
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0</code></pre>
  <p>Observa que las primeras siete líneas de este archivo son comentarios porque comienzan con el carácter <code>#</code>. Para añadir comentarios al archivo, inicia una línea con un carácter <code>#</code>. Los comentarios existentes recomiendan consultar las páginas de manual de los comandos <code>fstab</code>, <code>findfs</code>, <code>mount</code> y <code>blkid</code>.</p>
  <p>Las primeras cuatro columnas en el archivo <code>/etc/fstab</code> se mapean directamente a los parámetros utilizados para montar un sistema de archivos manualmente con el comando <code>mount</code>.</p>

  <h3>Identificador de Dispositivo</h3>
  <p>La primera columna identifica el dispositivo a montar. Podría ser el nombre de un dispositivo como <code>/dev/sdb1</code> en los ejemplos de montaje manual anteriores. Sin embargo, el archivo <code>/etc/fstab</code> se lee en el momento del arranque cuando el sistema no está atendido, por lo que no siempre es posible predecir el nombre de los dispositivos. Por ejemplo, si los cables SATA se intercambian durante el mantenimiento, el dispositivo <code>/dev/sda</code> puede cambiar de lugar con el dispositivo <code>/dev/sdb</code>.</p>

  <h4>UUID</h4>
  <p>Por esta razón, la forma más común de referirse a una partición es usando un identificador único universal (UUID), como en el siguiente ejemplo:</p>
  <pre><code>UUID=3db6ba40-67d2-403d-9c0a-9a901697cd8d /      ext4    defaults        1 1
UUID=09d641d5-bc5a-4065-8d80-8ae797dfa7f3 /boot  ext4    defaults        1 2
UUID=5ee634a5-c360-4211-a41b-9aa40d78a804 /home  ext4    defaults        1 2</code></pre>
  <p>Para determinar el valor UUID de un dispositivo, usa el comando <code>blkid</code>. La salida de este comando será similar a esta, aunque los UUID serán diferentes:</p>
  <pre><code>root@localhost:~# blkid
/dev/sda1: UUID="09d641d5-bc5a-4065-8d80-8ae797dfa7f3" TYPE="ext4"
/dev/sda2: UUID="3db6ba40-67d2-403d-9c0a-9a901697cd8d" TYPE="ext4"
/dev/sda3: UUID="34819281-65e3-4c78-ba2d-16952684c9cb" TYPE="swap"
/dev/sda5: UUID="5ee634a5-c360-4211-a41b-9aa40d78a804" TYPE="ext4"
/dev/sdb1: UUID="a9183c2c-ee1f-4e57-9a60-b0d9e87a0337" TYPE="ext4"
/dev/sdb2: UUID="71b38ae6-6824-4ad3-9e2f-821d7f532b97" TYPE="swap"</code></pre>
  <p>El comando <code>blkid</code> también se puede usar con un nombre de ruta para un sistema de archivos como argumento y proporcionará información solo sobre ese dispositivo:</p>
  <pre><code>root@localhost:~# blkid /dev/sdb1
/dev/sdb1: UUID="a9183c2c-ee1f-4e57-9a60-b0d9e87a0337" TYPE="ext4"</code></pre>
  <p>El UUID se crea automáticamente cuando se crea el sistema de archivos. Se considera la mejor manera de identificar sistemas de archivos locales en el archivo <code>/etc/fstab</code> porque no cambia después de que se ha creado el sistema de archivos y siempre debe ser único. Incluso si el disco duro se mueve a otra computadora, los UUID serán únicos para cada sistema de archivos. Desafortunadamente, el UUID no es fácil de recordar o escribir, por lo que es difícil de usar para el montaje manual.</p>

  <h4>Nombre del Dispositivo</h4>
  <p>Una segunda forma, más tradicional, de especificar un sistema de archivos local es usar el nombre de ruta para el dispositivo, como <code>/dev/sda1</code> para la primera partición en el primer disco:</p>
  <pre><code>/dev/sda1  /      ext4    defaults        1 1
/dev/sda2  /boot  ext4    defaults        1 2
/dev/sda5  /home  ext4    defaults        1 2</code></pre>
  <p>Si bien los nombres de ruta de dispositivos como <code>/dev/sdb1</code> son fáciles de recordar y escribir, no son tan confiables como los UUID. Como el nombramiento de la unidad de disco depende del orden de detección durante el proceso de arranque, el nombramiento de los discos podría cambiar si el orden de detección cambia (por ejemplo, cuando se añade una nueva unidad de disco al sistema).</p>

  <h4>Etiquetas</h4>
  <p>Otra opción es usar etiquetas de sistema de archivos. La etiqueta de volumen se puede establecer usando el comando <code>e2label</code>. Por ejemplo, el siguiente comando establecerá una etiqueta llamada <code>mydata</code> en el sistema de archivos <code>/dev/sdb1</code>:</p>
  <pre><code>root@localhost:~# e2label /dev/sdb1 mydata</code></pre>
  <p>La etiqueta de un sistema de archivos se puede ver con el comando <code>e2label</code>:</p>
  <pre><code>root@localhost:~# e2label /dev/sdb1
mydata</code></pre>
  <p>También se pueden crear etiquetas para el sistema de archivos de extensiones XFS, ya sea al crear el sistema de archivos o usando el comando <code>xfs_admin</code>:</p>
  <pre><code>root@localhost:~# xfs_admin -L myapps /dev/sdb3</code></pre>
  <p>Las etiquetas se pueden ver (si están configuradas) con el comando <code>blkid</code> al igual que los UUID. La salida del comando <code>blkid</code> es útil, ya que muestra cómo usar la etiqueta:</p>
  <pre><code>root@localhost:~# blkid /dev/sdb1
/dev/sdb1: UUID="a9183c2c-ee1f-4e57-9a60-b0d9e87a0337" TYPE="ext4" LABEL="mydata"</code></pre>
  <p>Las etiquetas se pueden usar en el primer campo del archivo <code>/etc/fstab</code>, como <code>LABEL="mydata"</code>. Si las etiquetas son creadas por un solo administrador, se pueden asegurar etiquetas únicas; sin embargo, múltiples usuarios con acceso de root pueden crear accidentalmente particiones con el mismo nombre de etiqueta:</p>
  <pre><code>LABEL="root" /      ext4    defaults        1 1
LABEL="boot" /boot  ext4    defaults        1 2
LABEL="home" /home  ext4    defaults        1 2</code></pre>
  <div class="warning">
    <p><strong>Advertencia:</strong> Ten cuidado con las etiquetas porque son generadas por humanos y pueden duplicarse al clonar un disco.</p>
    <p>Si el sistema detecta una etiqueta duplicada, es impredecible qué partición de disco montará realmente el sistema cuando se use esa etiqueta.</p>
  </div>
  <p>La siguiente tabla proporciona un resumen de estos tres métodos para referirse a la partición a montar:</p>
  <table>
    <thead>
      <tr>
        <th>Método</th>
        <th>Ventajas</th>
        <th>Desventajas</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>UUID</td>
        <td>Siempre debe ser único, evitando cualquier conflicto de montaje.</td>
        <td>Difícil de escribir y difícil de recordar.</td>
      </tr>
      <tr>
        <td>Nombre del Dispositivo</td>
        <td>Fácil de escribir y recordar.</td>
        <td>Los nombres de los dispositivos pueden cambiar fácilmente, causando errores de montaje.</td>
      </tr>
      <tr>
        <td>Etiqueta</td>
        <td>Fácil de escribir y recordar. Los nombres de las etiquetas no cambiarán dinámicamente como los nombres de los dispositivos, pero no siempre son únicos.</td>
        <td>Puede que no sea único como el nombramiento UUID.</td>
      </tr>
    </tbody>
  </table>

  <h3>Campo de Punto de Montaje</h3>
  <p>El segundo campo es el punto de montaje (directorio de montaje) donde se montará la partición. También corresponde al segundo parámetro del comando <code>mount</code>:</p>
  <pre><code>UUID=3db6ba40-67d2-403d-9c0a-9a901697cd8d /      ext4    defaults        1 1
UUID=09d641d5-bc5a-4065-8d80-8ae797dfa7f3 /boot  ext4    defaults        1 2
UUID=5ee634a5-c360-4211-a41b-9aa40d78a804 /home  ext4    defaults        1 2</code></pre>
  <p>No hay nada especial en un punto de montaje, es un directorio vacío que se creó con el comando <code>mkdir</code> para ese propósito o un directorio existente.</p>

  <h3>Campo de Sistema de Archivos</h3>
  <p>El tercer campo es el tipo de sistema de archivos. Introduce el Código de Tipo correcto usando los valores proporcionados por la siguiente tabla:</p>
  <table>
    <thead>
      <tr>
        <th>Nombre</th>
        <th>Código de Tipo</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Cuarto Sistema de Archivos Extendido</td>
        <td><code>ext4</code></td>
      </tr>
      <tr>
        <td>Tercer Sistema de Archivos Extendido</td>
        <td><code>ext3</code></td>
      </tr>
      <tr>
        <td>Segundo Sistema de Archivos Extendido</td>
        <td><code>ext2</code></td>
      </tr>
      <tr>
        <td>Sistema de Archivos de Extensión</td>
        <td><code>xfs</code></td>
      </tr>
      <tr>
        <td>Tabla de Asignación de Archivos</td>
        <td><code>vfat</code></td>
      </tr>
      <tr>
        <td>ISO 9660</td>
        <td><code>iso</code></td>
      </tr>
      <tr>
        <td>Formato de Disco Universal</td>
        <td><code>udf</code></td>
      </tr>
    </tbody>
  </table>
  <p>En la mayoría de los casos, el tipo de sistema de archivos para particiones regulares será el sistema de archivos <code>ext4</code>:</p>
  <pre><code>UUID=3db6ba40-67d2-403d-9c0a-9a901697cd8d /      ext4    defaults        1 1
UUID=09d641d5-bc5a-4065-8d80-8ae797dfa7f3 /boot  ext4    defaults        1 2
UUID=5ee634a5-c360-4211-a41b-9aa40d78a804 /home  ext4    defaults        1 2</code></pre>

  <h3>Campo de Opciones de Montaje</h3>
  <p>El cuarto campo en el archivo <code>/etc/fstab</code> es una lista separada por comas de las opciones de montaje que normalmente se pasarían a <code>mount</code> con las opciones <code>-o</code>. Este campo se utiliza para pasar parámetros al controlador del sistema de archivos, como para hacer que el dispositivo sea de solo lectura o para ajustar los tiempos de espera. La mayoría de los sistemas de archivos tienen una gran cantidad de opciones de montaje disponibles:</p>
  <pre><code>UUID=3db6ba40-67d2-403d-9c0a-9a901697cd8d /      ext4    defaults        1 1
UUID=09d641d5-bc5a-4065-8d80-8ae797dfa7f3 /boot  ext4    defaults        1 2
UUID=5ee634a5-c360-4211-a41b-9aa40d78a804 /home  ext4    defaults        1 2</code></pre>
  <p>La página de manual del comando <code>mount</code> proporciona documentación de algunas de las opciones de montaje que se aplican a todos los sistemas de archivos. Además, una búsqueda en la página de manual del comando <code>mount</code> resultará en la búsqueda de opciones de montaje para sistemas de archivos específicos. El siguiente es un extracto:</p>
  <pre><code>Opciones de montaje para ext4
       El sistema de archivos ext4 es un nivel avanzado del sistema de archivos ext3 que
       incorpora mejoras de escalabilidad y fiabilidad para soportar
       sistemas de archivos grandes.

       Las opciones journal_dev, noload, data, commit, orlov, oldalloc,
       [no]user_xattr [no]acl, bsddf, minixdf, debug, errors, data_err, grpid,
       bsdgroups, nogrpid sysvgroups, resgid, resuid, sb, quota, noquota,
       grpquota y usrquota son compatibles con ext3 o ext2.

       journal_checksum
              Habilita la verificación de sumas de control de las transacciones del diario. Esto permitirá
              al código de recuperación en e2fsck y al kernel detectar corrupción
              en el kernel. Es un cambio compatible y será
              ignorado por los kernels más antiguos.

       journal_async_commit
              El bloque de commit puede escribirse en disco sin esperar
              los bloques descriptores. Si está habilitado, los kernels más antiguos no pueden
              montar el dispositivo. Esto habilitará 'journal_checksum' internamente.</code></pre>
  <p>La página de manual del sistema de archivos particular a montar a menudo incluirá opciones de montaje útiles. Por ejemplo, al determinar las opciones de montaje para un sistema de archivos <code>ext4</code>, la página de manual de <code>mkfs.ext4</code> mostraría la documentación correcta.</p>
  <p>Anteriormente en este capítulo, se mencionó que las particiones podían montarse como solo lectura. Para evitar cualquier cambio en un sistema de archivos, coloca la opción de montaje de solo lectura en la línea correspondiente del archivo <code>/etc/fstab</code>:</p>
  <pre><code>UUID=3db6ba40-67d2-403d-9c0a-9a901697cd8d /date      ext4    ro        1 1</code></pre>
  <p>La opción de montaje más común es la opción <code>defaults</code>. La opción de montaje <code>defaults</code> implica que una serie de opciones de montaje estándar están en vigor. La siguiente tabla enumera las opciones de montaje que están en vigor cuando se usa <code>defaults</code>, el propósito de la opción de montaje y la opción que es opuesta a la opción de montaje predeterminada (si está disponible):</p>
  <table>
    <thead>
      <tr>
        <th>Opción de Montaje</th>
        <th>Propósito</th>
        <th>Opuesta</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>rw</code></td>
        <td>Permitir lectura y escritura</td>
        <td><code>ro</code></td>
      </tr>
      <tr>
        <td><code>suid</code></td>
        <td>Permitir ejecuciones <code>suid</code></td>
        <td><code>nosuid</code></td>
      </tr>
      <tr>
        <td><code>dev</code></td>
        <td>Permitir archivos de dispositivo</td>
        <td><code>nodev</code></td>
      </tr>
      <tr>
        <td><code>exec</code></td>
        <td>Permitir archivos ejecutables</td>
        <td><code>noexec</code></td>
      </tr>
      <tr>
        <td><code>auto</code></td>
        <td>Montar automáticamente</td>
        <td><code>noauto</code></td>
      </tr>
      <tr>
        <td><code>nouser</code></td>
        <td>Impedir que los usuarios ordinarios monten o desmonten la partición. Usar la opción <code>user</code> permite a los usuarios no root montar ese dispositivo en particular, lo cual es útil para medios extraíbles.</td>
        <td><code>user</code></td>
      </tr>
      <tr>
        <td><code>async</code></td>
        <td>Todas las escrituras deben ser asíncronas</td>
        <td><code>sync</code></td>
      </tr>
      <tr>
        <td><code>relatime</code></td>
        <td>Solo actualizar el tiempo de acceso al acceder a un archivo si el archivo ha sido modificado o sus metadatos han cambiado desde el último acceso</td>
        <td>N/A</td>
      </tr>
    </tbody>
  </table>
  <p>Usar la palabra clave <code>defaults</code> es más claro y rápido que especificar cada opción individual.</p>
  <p>Si se van a usar varias opciones, deben estar separadas por una coma y no tener espacios incrustados. Cualquier opción no especificada seguirá usando los valores predeterminados, por lo que usar la palabra clave <code>defaults</code> puede considerarse como un simple marcador de posición.</p>
  <p>La siguiente configuración seguirá montada en modo de lectura/escritura, permitirá archivos ejecutables, y así sucesivamente:</p>
  <pre><code>UUID=3db6ba40-67d2-403d-9c0a-9a901697cd8d /date      ext4    nosuid,nodev   1 1</code></pre>
  <p>Es interesante observar que al usar <code>defaults</code> para las opciones de montaje, la única opción de montaje que se mostrará cuando se ejecute el comando <code>mount</code> será la opción <code>rw</code>:</p>
  <pre><code>/dev/sda2 on / type ext4 (rw)</code></pre>

  <h3>Campo Dump</h3>
  <pre><code>UUID=3db6ba40-67d2-403d-9c0a-9a901697cd8d /      ext4    defaults        1 1
UUID=09d641d5-bc5a-4065-8d80-8ae797dfa7f3 /boot  ext4    defaults        1 2
UUID=34819281-65e3-4c78-ba2d-16952684c9cb swap   swap    defaults        0 0</code></pre>
  <p>El propósito de este campo es indicar a un administrador qué sistemas de archivos deben ser respaldados al usar el comando <code>dump</code>. El administrador ejecutaría el comando <code>dump -w</code> y la salida resultante sería una lista de los sistemas de archivos a respaldar. Esta lista se genera a partir de los sistemas de archivos que tienen un valor de <code>1</code> en el campo <code>dump</code> del archivo <code>/etc/fstab</code>. Un valor de <code>1</code> en este campo se usa para sistemas de archivos reales locales (sistemas de archivos en particiones que residen en discos duros locales). Cualquier pseudo-sistema de archivos, sistemas de archivos remotos o entradas de espacio de swap deben tener un valor de <code>0</code> en este campo.</p>
  <p>Esto está un poco desactualizado, ya que el comando <code>dump</code> rara vez es utilizado por los administradores de sistemas en las distribuciones de Linux modernas. Sin embargo, es importante saberlo, ya que el archivo <code>/etc/fstab</code> requiere una entrada válida en este campo.</p>

  <h3>Campo de Verificación del Sistema de Archivos</h3>
  <pre><code>UUID=3db6ba40-67d2-403d-9c0a-9a901697cd8d /      ext4    defaults        1 1
UUID=09d641d5-bc5a-4065-8d80-8ae797dfa7f3 /boot  ext4    defaults        1 2
UUID=34819281-65e3-4c78-ba2d-16952684c9cb swap   swap    defaults        0 0</code></pre>
  <p>El sexto campo es para determinar el orden en que los sistemas de archivos serán verificados por la utilidad <code>fsck</code> (File System ChecK) durante el arranque del sistema. Esta utilidad está diseñada para encontrar y corregir problemas del sistema de archivos.</p>
  <p>El sistema de archivos raíz siempre debe tener un <code>1</code> en este campo para indicar que será verificado por el programa <code>fsck</code> primero. Todos los demás sistemas de archivos locales (ext2/ext3/ext4) deben tener un valor de <code>2</code> especificado para este campo, por lo que se verificarán después del sistema de archivos raíz.</p>
  <p>Si los sistemas de archivos están dentro de la misma unidad, se verificarán secuencialmente, pero si están en unidades separadas, se verificarán en paralelo, si es posible.</p>
  <p>Cualquier pseudo-sistema de archivos, sistemas de archivos remotos o entradas de espacio de swap deben tener un valor de <code>0</code> en este campo. Estos sistemas de archivos nunca deben ser verificados por la utilidad <code>fsck</code>.</p>
  <div class="note">
    <p><strong>Nota:</strong> La utilidad <code>fsck</code> se cubrirá con mayor detalle en un capítulo posterior, ya que también se puede usar como un programa interactivo.</p>
  </div>
  </section>
  <hr>
  
  <section id="21-6">
  <h2>21.6 Montaje con fstab</h2>
  <p>Otra característica útil de <code>mount</code> requiere discusión, pasar solo un argumento, como:</p>
  <pre><code>root@localhost:~# mount /home</code></pre>
  <p>Linux leerá la configuración para este montaje del archivo <code>/etc/fstab</code> si existe. Esto permite crear un nuevo montaje en <code>/etc/fstab</code> y luego probarlo sin necesidad de un reinicio. También se puede usar para remontar un volumen que ha sido puesto fuera de línea para mantenimiento.</p>
  <p>También hay una opción de montaje valiosa que nunca se especificará en el archivo <code>/etc/fstab</code>: la opción <code>remount</code>. Esta opción es útil para cambiar las opciones de un sistema de archivos montado sin desmontar el sistema de archivos en sí.</p>
  <pre><code>root@localhost:~# mount /home -o remount,noatime</code></pre>
  <p>Este comando cambiará el montaje de <code>/home</code> para que tenga la opción <code>noatime</code> (la opción <code>atime</code> muestra la última vez que se accedió o leyó un archivo) sin necesidad de remontar el sistema de archivos. Ten en cuenta que esto no persistirá después de un reinicio hasta que el archivo <code>fstab</code> se haya actualizado. Una vez que se hayan realizado cambios en el archivo <code>fstab</code>, ejecuta algo como lo siguiente para que surtan efecto:</p>
  <pre><code>root@localhost:~# mount -o remount /mnt</code></pre>
  <p>Remontar es diferente de ejecutar el comando <code>umount</code> en un sistema de archivos y luego ejecutar el comando <code>mount</code> en ese mismo sistema de archivos. Mientras que el desmontaje/montaje fallará en un sistema de archivos en uso, el remontaje es realmente solo cambiar las opciones de montaje y tendrá éxito en un sistema de archivos en uso.</p>
  <p>Después de actualizar el archivo <code>/etc/fstab</code>, no reinicies el sistema para probar los cambios. En su lugar, usa la opción <code>-o remount</code>. Si los cambios son correctos, no se mostrará ningún mensaje, pero si se cometió un error, se mostrará un error como el siguiente:</p>
  <pre><code>root@localhost:~# mount -o remount /
mount: / no está montado, o la opción es incorrecta</code></pre>
  <p>Si no hay errores en la entrada correspondiente contenida en el archivo <code>/etc/fstab</code>, el comando <code>mount -o</code> no producirá ninguna salida.</p>
  <p>La opción <code>remount</code> es útil, pero puede generar problemas si el administrador permite que el archivo <code>/etc/fstab</code> se desincronice con la configuración en ejecución.</p>
  </section>
  <hr>

  <section id="21-7">
  <h2>21.7 Unidades de montaje de Systemd</h2>
  <p>Otro enfoque para montar sistemas de archivos es mediante el uso de unidades de montaje de systemd. Las unidades de montaje de Systemd son archivos de configuración que terminan en <code>.mount</code> y contienen información sobre los recursos que se montarán al inicio.</p>
  <p>Estos archivos contienen una sección <code>Mount</code> que tiene información sobre el punto de montaje del sistema de archivos, y deben nombrarse según la ruta específica a montar. Los montajes que se enumeran en el archivo <code>/etc/fstab</code> se convierten en tiempo de arranque y cuando se recarga el gestor del sistema.</p>
  <p>La utilidad <code>systemd-mount</code> es el mecanismo que systemd usa para crear y iniciar un archivo <code>.mount</code> transitorio, destruir un archivo <code>.mount</code> transitorio o iniciar una unidad <code>.automount</code> del sistema de archivos.</p>
  <p>A continuación se muestra un ejemplo de un archivo <code>.mount</code> utilizado para una instalación snap de software. Los Snaps son archivos de instalación de software que se pueden usar en varias distribuciones de Linux en lugar de los instaladores binarios específicos utilizados por Ubuntu, Red Hat y otras distribuciones.</p>
  <pre><code>[Unit]

Description=Mount unit for core, revision 6673

Before=snapd.service

[Mount]

What=/var/lib/snapd/snaps/core_6673.snap

Where=/snap/core/6673

Type=squashfs

Options=nodev,ro,x-gdu.hide

[Install]

WantedBy=multi-user.target</code></pre>
  <p>En el ejemplo anterior, se creó una unidad de montaje snap para instalar software en el contenido del archivo de montaje anterior. A continuación se desglosan los campos y opciones en un archivo de montaje.</p>

  <h3>El campo <code>[Unit]</code>:</h3>
  <pre><code>[Unit]
 
Description=Mount unit for core, revision 6673
 
Before=snapd.service</code></pre>
  <table>
    <thead>
      <tr>
        <th>Campo</th>
        <th>Propósito</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Description</code></td>
        <td>Muestra qué unidad de montaje se va a montar.</td>
      </tr>
      <tr>
        <td><code>Before</code></td>
        <td>Muestra el archivo <code>snapd.service</code> como el nombre del archivo a montar.</td>
      </tr>
    </tbody>
  </table>

  <h3>El campo <code>[Mount]</code>:</h3>
  <pre><code>[Mount]
 
What=/var/lib/snapd/snaps/core_6673.snap
 
Where=/snap/core/6673
 
Type=squashfs
 
Options=nodev,ro,x-gdu.hide</code></pre>
  <table>
    <thead>
      <tr>
        <th>Campo</th>
        <th>Propósito</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>What</code></td>
        <td>El archivo a montar, incluyendo su ruta. Ten en cuenta que se debe usar una ruta absoluta en el nombre de la unidad de montaje que controla.</td>
      </tr>
      <tr>
        <td><code>Where</code></td>
        <td>La ubicación donde se montará.</td>
      </tr>
      <tr>
        <td><code>Type</code></td>
        <td>El tipo de sistema de archivos en el que está almacenado el archivo. En el ejemplo anterior, es <code>squashfs</code>, el sistema de archivos comprimido y de solo lectura.</td>
      </tr>
      <tr>
        <td><code>Options</code></td>
        <td>Define las opciones específicas a utilizar. La opción <code>nodev</code> es una característica de seguridad que impide que los dispositivos especiales de bloque (que podrían permitir la ejecución de código dañino) se monten en el sistema de archivos. La opción <code>ro</code> significa solo lectura y la opción <code>x-gdu.hide</code> evita que el montaje snap sea visible para el Monitor del Sistema.</td>
      </tr>
    </tbody>
  </table>

  <h3>El campo <code>[Install]</code>:</h3>
  <pre><code>[Install]
 
WantedBy=multi-user.target</code></pre>
  <table>
    <thead>
      <tr>
        <th>Campo</th>
        <th>Propósito</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>WantedBy</code></td>
        <td>Le dice a systemd que este sistema de archivos debe ser utilizado por el objetivo de arranque multiusuario.</td>
      </tr>
    </tbody>
  </table>
  <p>Aunque la configuración de la unidad de montaje permite un montaje más flexible de recursos, un caso para los recursos de red sería donde es deseable tener la capacidad de definir cosas como cuánto tiempo esperar para que el comando de montaje finalice. Sin embargo, en muchos casos, el uso del archivo <code>fstab</code> sigue siendo el enfoque preferido.</p>
  </section>
  <hr>

  <section id="21-8">
  <h2>21.8 Opción loop</h2>
  <p>La opción <code>loop</code> del comando <code>mount</code> se utiliza para montar sistemas de archivos especiales que se almacenan dentro de un archivo. Estos archivos tienen la extensión <code>.img</code> o <code>.iso</code> (para archivos de sistema de archivos ISO 9660), que contienen sistemas de archivos completos que pueden montarse con el comando <code>mount</code> utilizando la opción <code>loop</code>:</p>
  <pre><code>root@localhost:~# mount -o loop fs.img /mnt
root@localhost:~# mount -o loop cdrom.iso /mnt</code></pre>
  <p>Para comprender mejor el propósito de la opción <code>loop</code>, considera el siguiente escenario: Un administrador de sistemas ha recibido instrucciones para descargar un archivo ISO llamado <code>software.iso</code> de Internet. Este archivo ISO contiene varios paquetes de software RPM que deben instalarse en algunos sistemas locales. El administrador tiene dos opciones: grabar un DVD con el archivo ISO, o montar el archivo ISO como parte del sistema de archivos. Para conservar recursos, el administrador elige montar el archivo ISO.</p>
  <p>Para obtener acceso a estos paquetes de software, que terminan todos con la extensión <code>.rpm</code>, el administrador de sistemas monta el archivo ISO y luego copia los paquetes de software ejecutando los siguientes comandos:</p>
  <pre><code>root@localhost:~# mount -o loop software.iso /mnt
root@localhost:~# mkdir /root/latestrpms
root@localhost:~# cp /mnt/*.rpm /root/latestrpms</code></pre>
  <p>Después de copiar los paquetes de software al directorio <code>/root/latestrpms</code>, el archivo <code>software.iso</code> se puede desmontar y eliminar del sistema.</p>

  <div class="note">
    <p><strong>Nota:</strong> Casi todo en Linux es un archivo, incluidos los discos ópticos. Si hay una imagen de un disco dentro de un archivo, se puede montar directamente desde el archivo sin necesidad de grabar la imagen de nuevo en un disco utilizando la opción <code>loop</code>.</p>
  </div>
  </section>
  <hr>

  <section id="21-9">
  <h2>21.9 Monitoreo de sistemas de archivos</h2>
  <p>El comando <code>df</code> también se puede usar para ver los sistemas de archivos montados. La salida de este comando muestra el uso del sistema de archivos, dónde está montado y el uso de espacio del dispositivo. Para que el comando <code>df</code> muestre los tamaños del sistema de archivos en un formato legible para humanos, usa la opción <code>-h</code>. Usa la opción <code>-T</code> para que el comando <code>df</code> muestre el tipo de sistema de archivos:</p>
  <pre><code>root@localhost:~# df -hT
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/sda2     ext4    6.3G  3.2G  2.9G  53% /
tmpfs        tmpfs    351M   84K  351M   1% /dev/shm
/dev/sda1     ext4    485M   52M  408M  12% /boot
/dev/sda5     ext4    2.2G   69M  2.0G   4% /home</code></pre>
  <p>La salida muestra los sistemas de archivos que tienen espacio libre variable; el sistema de archivos <code>tmpfs</code>, que es similar a un disco RAM, entra en esta categoría, mientras que otros pseudo-sistemas de archivos como el sistema de archivos <code>proc</code>, no.</p>
  </section>
  <hr>

  <section id="21-10">
  <h2>21.10 Montar un Sistema de Archivos</h2>
  <p>Lo siguiente describe cómo configurar un nuevo sistema de archivos que se ha creado en el dispositivo <code>/dev/sdb1</code> para que se monte automáticamente durante el proceso de arranque. Se añadirá una sola línea al final del archivo <code>/etc/fstab</code>. La suposición para este ejemplo es que la partición ha sido creada con el comando <code>fdisk</code> y el sistema de archivos ha sido creado con el comando <code>mkfs</code>.</p>
  <p>Antes de modificar el archivo <code>/etc/fstab</code>, primero, recopila la información necesaria. Usa el comando <code>blkid</code> para determinar el UUID o la etiqueta del nuevo sistema de archivos. El resultado será similar al siguiente:</p>
  <pre><code>root@localhost:~# blkid dev/sdb1
/dev/sdb1: UUID="a9183c2c-ee1f-4e57-9a60-b0d9e87a0337" TYPE="ext4" LABEL="mydata"</code></pre>
  <p>En este ejemplo, se utilizará la etiqueta del sistema de archivos. Por lo tanto, el primer campo debe ser:</p>
  <pre><code>LABEL="mydata"</code></pre>
  <p>A continuación, crea un punto de montaje en el árbol existente con el comando <code>mkdir</code>:</p>
  <pre><code>root@localhost:~# mkdir /data</code></pre>
  <p>Ahora, coloca lo siguiente como el segundo campo:</p>
  <pre><code>LABEL="mydata" /data</code></pre>
  <p>Suponiendo que el sistema de archivos en la partición es del tipo Cuarto Extendido, el valor para el tercer campo será:</p>
  <pre><code>LABEL="mydata" /data ext4</code></pre>
  <p>A menos que haya una razón imperiosa para no hacerlo, usa <code>defaults</code> para el campo de opciones de montaje especificando el valor para el cuarto campo como:</p>
  <pre><code>LABEL="mydata" /data ext4 defaults</code></pre>
  <p>Dado que <code>/dev/sdb1</code> está formateado como un sistema de archivos <code>ext4</code> y este dispositivo es local al sistema, el quinto campo (la verificación de <code>dump</code>) debe habilitarse con el valor de:</p>
  <pre><code>LABEL="mydata" /data ext4 defaults 1</code></pre>
  <p>Por la misma lógica, el sexto campo debe tener el valor:</p>
  <pre><code>LABEL="mydata" /data ext4 defaults 1 2</code></pre>
  <p>Juntando todos estos campos para la entrada normal en el archivo <code>/etc/fstab</code> resulta en la siguiente línea:</p>
  <pre><code>LABEL="mydata"  
/data
ext4
defaults
1
2</code></pre>
  <table>
    <thead>
      <tr>
        <th>Dispositivo</th>
        <th>Punto de Montaje</th>
        <th>Sistema de Archivos</th>
        <th>Opciones</th>
        <th>dump</th>
        <th>fsck</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>LABEL="mydata"</code></td>
        <td><code>/data</code></td>
        <td><code>ext4</code></td>
        <td><code>defaults</code></td>
        <td><code>1</code></td>
        <td><code>2</code></td>
      </tr>
    </tbody>
  </table>
  <p>Después de modificar el archivo <code>/etc/fstab</code>, verifica que la nueva línea se haya añadido correctamente montando el sistema de archivos con solo el punto de montaje o el nombre del dispositivo como argumento:</p>
  <pre><code>root@localhost:~# mount /data
root@localhost:~# mount /dev/sdb1</code></pre>
  <div class="important">
    <p><strong>Importante:</strong> Si hay un error al intentar montar el sistema de archivos, vuelve atrás y corrige el archivo <code>/etc/fstab</code> o restaura la copia de seguridad de este archivo. No reinicies el sistema hasta que se corrija el error; los errores en el archivo <code>/etc/fstab</code> pueden impedir que el sistema arranque.</p>
  </div>
  </section>
  <hr>

  <section id="21-11">
  <h2>21.11 Activar espacio de Swap</h2>
  <p>Lo siguiente describe cómo configurar una nueva partición swap que se ha creado en el dispositivo <code>/dev/sdb2</code> para que se active automáticamente durante el proceso de arranque. Se añadirá una sola línea al final del archivo <code>/etc/fstab</code>. La suposición aquí es que la partición ha sido creada con el comando <code>fdisk</code> y la partición ha sido configurada como una partición swap con el comando <code>mkswap</code>.</p>
  <p>Para el primer campo, especifica el dispositivo. De nuevo, usa el comando <code>blkid</code> para recopilar la información sobre esta partición. La salida se vería algo como lo siguiente:</p>
  <pre><code>root@localhost:~# blkid /dev/sdb2
/dev/sdb2: UUID="6f450a83-9d2e-409f-8bce-826696a49e54" TYPE="swap" LABEL="myswap"</code></pre>
  <p>En este ejemplo, se utilizará la etiqueta swap. Por lo tanto, el primer campo debe ser:</p>
  <pre><code>LABEL="myswap"</code></pre>
  <div class="important">
    <p><strong>Importante:</strong> Al crear una entrada para un archivo swap en lugar de una partición swap, usa siempre el nombre de la ruta para el archivo swap, como <code>/root/swapfile</code>. Esta es la única configuración en la entrada de <code>/etc/fstab</code> que será diferente para un archivo swap que para una partición swap.</p>
  </div>
  <p>Para el punto de montaje en el segundo campo, todas las particiones swap siempre usan lo siguiente:</p>
  <pre><code>LABEL="myswap" swap</code></pre>
  <p>Para el tipo de sistema de archivos en el tercer campo, todas las particiones swap siempre usan lo siguiente:</p>
  <pre><code>LABEL="myswap" swap swap</code></pre>
  <p>La opción de montaje <code>defaults</code> se puede usar con particiones swap o archivos swap, al igual que se puede usar con sistemas de archivos regulares. En la mayoría de los casos, usar <code>defaults</code> está bien para el rendimiento si todos los dispositivos swap son iguales en rendimiento de lectura/escritura; para este ejemplo, la opción <code>defaults</code> funcionará bien para el valor del cuarto campo:</p>
  <pre><code>LABEL="myswap" swap swap defaults</code></pre>

  <div class="consider-this">
    <h3>Considera esto</h3>
    <p>Considera la opción de montaje <code>pri</code> para particiones swap. Esta opción de montaje permitirá diferentes prioridades para diferentes espacios swap. Cuanto mayor sea la prioridad de un dispositivo swap, más probable será que el kernel de Linux use esa área.</p>
    <p>Por ejemplo, si un archivo swap tiene una opción de montaje de <code>pri=1</code> y una partición swap tiene una opción de montaje de <code>pri=2</code>, entonces la partición swap tendrá una prioridad más alta y será más probable que se use que el archivo swap.</p>
    <p>En general, las particiones swap deben tener un mejor rendimiento que los archivos swap porque el kernel necesita pasar por el sistema de archivos regular para acceder a los archivos swap. Esto ralentizará el tiempo de acceso. Por lo tanto, cuando uses tanto particiones swap como archivos swap, asigna una prioridad más alta a la partición swap que al archivo swap.</p>
  </div>
  <p>Los campos quinto y sexto, la verificación de <code>dump</code> y los campos de verificación del sistema de archivos, nunca se habilitan para particiones swap o archivos swap, por lo que ambos deben ser cero:</p>
  <pre><code>LABEL="myswap" swap swap defaults 0 0</code></pre>
  <p>Juntando todos estos campos para la partición swap normal en el archivo <code>/etc/fstab</code> resulta en la siguiente línea:</p>
  <pre><code>LABEL="myswap"
swap
swap
defaults
0
0</code></pre>
  <table>
    <thead>
      <tr>
        <th>Dispositivo</th>
        <th>Punto de Montaje</th>
        <th>Sistema de Archivos</th>
        <th>Opciones</th>
        <th>dump</th>
        <th>fsck</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>LABEL="myswap"</code></td>
        <td><code>swap</code></td>
        <td><code>swap</code></td>
        <td><code>defaults</code></td>
        <td><code>0</code></td>
        <td><code>0</code></td>
      </tr>
    </tbody>
  </table>
  <p>Para verificar que la partición o archivo swap se ha añadido correctamente, usa el comando <code>swapon -a</code>; esto activará todas las entradas swap en el archivo <code>/etc/fstab</code>. Los errores sobre no poder activar espacios que ya estaban activos se pueden ignorar, pero los errores al intentar activar el nuevo espacio swap deben corregirse en el archivo <code>/etc/fstab</code> antes de reiniciar, o puede haber problemas más adelante.</p>
  <p>Después de usar el comando <code>swapon -a</code>, verifica que la partición o archivo swap ahora esté activado usando el comando <code>swapon -s</code>. Si la salida incluye la nueva partición swap, la entrada debe ser correcta en el archivo <code>/etc/fstab</code>.</p>
  <p>Como se mencionó anteriormente, la única diferencia en una línea que describe una partición swap versus un archivo swap es el primer campo:</p>
  <pre><code>/var/swapfile
swap
swap
defaults
0
0</code></pre>
  <table>
    <thead>
      <tr>
        <th>Dispositivo</th>
        <th>Punto de Montaje</th>
        <th>Sistema de Archivos</th>
        <th>Opciones</th>
        <th>dump</th>
        <th>fsck</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>/var/swapfile</code></td>
        <td><code>swap</code></td>
        <td><code>swap</code></td>
        <td><code>defaults</code></td>
        <td><code>0</code></td>
        <td><code>0</code></td>
      </tr>
    </tbody>
  </table>
  </section>
  <hr>
  
  <hr>
  <div class="volver">
    <a href="../index.html">← Volver al índice</a>
  </div>

</body>
</html>
