<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Capítulo 1X</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      margin: 0;
      padding: 2rem;
      max-width: 800px;
      margin: auto;
    }
    h1 {
      color: #333;
      text-align: center;
    }
    p {
      line-height: 1.6;
      color: #444;
    }
    .volver {
      display: block;
      margin-top: 2rem;
      text-align: center;
    }
    .volver a {
      color: #0077cc;
      text-decoration: none;
      font-weight: bold;
    }
    .volver a:hover {
      color: #005999;
    }
  </style>
</head>
<body>
  <h1>Capítulo 18</h1>

  <nav>
    <ul>
      <li><a href="#1X-1">18.1 Introducción</a></li>
      <li><a href="#1X-2">18.2</a></li>
      <li><a href="#1X-3">18.3</a></li>
      <li><a href="#1X-4">18.4</a></li>
      <li><a href="#1X-5">18.5</a></li>
      <li><a href="#1X-6">18.6</a></li>
      <li><a href="#1X-7">18.7</a></li>
      <li><a href="#1X-8">18.8</a></li>
      <li><a href="#1X-9">18.9</a></li>
      <li><a href="#1X-10">18.10</a></li>
    </ul>
  </nav> 

  <section id="18-1">
  <h2>18.1 Introducción</h2>
  <p>Linux utiliza el concepto de diferentes <strong>runlevels</strong> (niveles de ejecución) para definir qué servicios o procesos estarán en funcionamiento. Aunque el kernel de Linux puede reconocer valores de runlevel del 0 al 9, típicamente solo se utilizan los runlevels del 0 al 6. Tradicionalmente, <strong>init</strong> y <strong>Upstart</strong> usaban estos runlevels para definir qué servicios se iniciaban de acuerdo con las necesidades de un runlevel particular. Ser capaz de definir un runlevel específico es esencial para la resolución de problemas en sistemas cuando los componentes de software, como los controladores de hardware, están causando fallos en el kernel.</p>

  <p>Recientemente, estos programas han sido reemplazados en muchas distribuciones por <strong>systemd</strong>, un gestor de servicios y sistemas diseñado originalmente por Red Hat. systemd hace algo similar a los runlevels llamado <strong>targets</strong>, que se muestran en la siguiente tabla con su equivalente de runlevel.</p>

  <p>La **Linux Standards Base 4.1** define el propósito de cada runlevel de la siguiente manera:</p>

  <table>
    <thead>
      <tr>
        <th>Runlevel</th>
        <th>Propósito</th>
        <th>systemd Target</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0</td>
        <td>Detener o apagar el sistema</td>
        <td>poweroff.target</td>
      </tr>
      <tr>
        <td>1</td>
        <td>Modo monousuario para tareas administrativas</td>
        <td>rescue.target</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Modo multiusuario sin interfaces de red configuradas o servicios de red</td>
        <td>multi-user.target</td>
      </tr>
      <tr>
        <td>3</td>
        <td>Arranque normal del sistema</td>
        <td>multi-user.target</td>
      </tr>
      <tr>
        <td>4</td>
        <td>Definible por el usuario</td>
        <td>multi-user.target</td>
      </tr>
      <tr>
        <td>5</td>
        <td>Iniciar el sistema normalmente con un gestor de pantalla gráfico</td>
        <td>graphical.target</td>
      </tr>
      <tr>
        <td>6</td>
        <td>Reiniciar el sistema</td>
        <td>reboot.target</td>
      </tr>
    </tbody>
  </table>

  <p>Aunque estos runlevels se consideran "estándar", no todas las distribuciones los utilizan para los mismos propósitos. Consulta la documentación que viene con tu distribución para confirmar el propósito de cada runlevel. De hecho, para los sistemas que ya no utilizan el proceso init tradicional, el uso de runlevels solo puede proporcionarse para mantener la compatibilidad con procesos que puedan esperarlos.</p>
  </section>
  <hr>
  
  <section id="18-2">
  <h2>18.2 Runlevel Predeterminado</h2>
  <p>Los sistemas que utilizan el <strong>init tradicional</strong> pueden especificar el runlevel predeterminado modificando la entrada del archivo <code>/etc/inittab</code> que se ve de la siguiente manera:</p>

  <pre><code>id:5:initdefault:</code></pre>

  <p>En este ejemplo, el runlevel predeterminado indicado es que el sistema vaya al runlevel 5, lo cual es típico para un sistema de escritorio o portátil que ejecutará una interfaz gráfica de usuario (GUI) y, muy probablemente, será utilizado por un usuario final. Para la mayoría de los sistemas Linux, el runlevel 5 proporciona el nivel más alto de funcionalidad, incluyendo una interfaz GUI.</p>

  <p>Los servidores típicamente no ofrecen una interfaz GUI, por lo que la entrada <code>initdefault</code> podría verse así:</p>

  <pre><code>id:3:initdefault:</code></pre>

  <p>Como se discutió anteriormente, el runlevel predeterminado puede ser anulado en el momento del arranque interactuando con el gestor de arranque. En el caso de <strong>GRUB Legacy</strong>, ya sea añadiendo al final de la línea del kernel o usando la función de edición para agregar un número de runlevel. Por ejemplo, añadir <code>5</code> llevaría el sistema al runlevel 5 y la palabra <code>single</code> (o la letra <code>s</code> en mayúsculas o minúsculas, así como el número <code>1</code>) llevaría el sistema al runlevel de usuario único.</p>

  <div class="note">
    <p><strong>Nota:</strong> Los gestores de arranque se cubren con mayor detalle anteriormente en el curso.</p>
  </div>

  <p>Si el sistema está usando <strong>Upstart</strong> en lugar del proceso init tradicional, entonces el runlevel predeterminado también puede establecerse en el archivo <code>/etc/inittab</code>, como es el caso de las distribuciones derivadas de Red Hat Enterprise Linux 6. Por otro lado, las distribuciones como Ubuntu (la distribución que desarrolló Upstart) pueden cambiarse estableciendo la variable de entorno <code>DEFAULT_RUNLEVEL</code> en el archivo <code>/etc/init/rc-sysinit.conf</code>.</p>

  <p><strong>systemd</strong> no utiliza runlevels de forma nativa, pero tiene algo similar llamado <strong>targets</strong>. Por ejemplo, el <code>graphical.target</code> es similar al runlevel 5 estándar, donde la GUI está funcionando; el <code>multi-user.target</code> es similar al runlevel 3 estándar, donde el sistema funciona normalmente sin una GUI.</p>

  <p>Para establecer un target predeterminado, crea un enlace simbólico desde la definición del target que se encuentra en el directorio <code>/lib/systemd</code> al archivo <code>/etc/systemd/system/default.target</code>. Este archivo es un enlace simbólico que controla dónde arranca el sistema por primera vez.</p>

  <div class="note">
    <p><strong>Nota:</strong> Recuerda que para crear un archivo de enlace blando, usa el comando <code>ln</code> con la opción <code>-s</code>. El primer argumento es el nombre del archivo original, y el segundo argumento es el nombre del enlace a crear:</p>
    <pre><code>ln -s target link_name</code></pre>
    <p>Los enlaces se cubren con mayor detalle al principio del curso.</p>
  </div>

  <p>Para cambiar cómo arranca el sistema, elimina el anterior target predeterminado y luego crea un nuevo enlace simbólico como se muestra a continuación:</p>

  <div class="note">
    <p><strong>Nota:</strong> El comando <code>su</code> requiere la contraseña de root <code>netlab123</code> en nuestro entorno virtual.</p>
  </div>

  <pre><code>sysadmin@localhost:~$ su -
Password:
root@localhost:~# rm -f /etc/systemd/system/default.target
root@localhost:~# ln -sf /lib/systemd/system/graphical.target \
/etc/systemd/system/default.target</code></pre>

  <p>El ejemplo anterior establece el target predeterminado a <code>graphical.target</code>, por lo que el sistema se iniciaría en un estado similar al runlevel 5.</p>
  </section>
  <hr>
  <section id="18-3">
  <h2>18.3 Visualización del Runlevel Actual</h2>
  <p>A pesar de tener un runlevel predeterminado, un sistema puede estar en un runlevel diferente, ya sea porque fue anulado en el momento del arranque o porque pudo haber sido cambiado después de que el sistema arrancó.</p>

  <p>Uno de los comandos que muestra el runlevel actual es el comando <code>runlevel</code>, que muestra primero el runlevel anterior, seguido del runlevel actual. Si no se alcanzó ningún runlevel anterior, mostrará una <code>N</code> para el runlevel previo. Esto significa que el sistema arrancó directamente en el runlevel actual y no ha cambiado.</p>

  <div class="note">
    <p><strong>Nota:</strong> Los siguientes ejemplos representan un sistema diferente de la máquina virtual de este módulo. Los ejemplos pueden no coincidir con la salida en nuestro entorno virtual.</p>
  </div>

  <p>El siguiente ejemplo demuestra la ejecución del comando <code>runlevel</code> cuando el sistema acaba de arrancar en el runlevel 5:</p>

  <pre><code>root@ubuntu:~# runlevel
N 5</code></pre>

  <p>El comando <code>who -r</code> también muestra el runlevel actual del sistema. Un beneficio de esta técnica es que mostrará la fecha y hora en que se alcanzó el runlevel actual:</p>

  <pre><code>root@ubuntu:~# who -r
        run-level 3  2023-05-29 14:25</code></pre>

  <p>Aunque <strong>systemd</strong> en realidad no utiliza runlevels, traduce transparentemente su target actual como un runlevel para compatibilidad con los comandos <code>runlevel</code> y <code>who -r</code>. Si un sistema ha alcanzado el <code>multi-user.target</code>, esto se traducirá al runlevel 3; si un sistema ha alcanzado el <code>graphical.target</code>, esto se traduce al runlevel 5.</p>
  </section>
  <hr>

  <section id="18-4">
  <h2>18.4 Cambiando Runlevels y Targets</h2>
  <p>Tanto <strong>SysVinit tradicional</strong> como <strong>Upstart</strong> soportan pasar runlevels al kernel como parámetros desde el gestor de arranque para anular el runlevel predeterminado.</p>

  <p>Para especificar un runlevel diferente en el momento del arranque en un sistema que utiliza <strong>systemd</strong>, añade a los parámetros del kernel una opción con la siguiente sintaxis, donde <code>DESIRED.TARGET</code> es uno de los targets de systemd:</p>

  <pre><code>systemd.unit=DESIRED.TARGET</code></pre>

  <p>El usuario <code>root</code> también puede cambiar los runlevels mientras el sistema operativo está en funcionamiento utilizando varios comandos, incluidos los comandos <code>init</code> y <code>telinit</code>, que permiten especificar el runlevel deseado. También hay varios comandos que no especifican directamente el número de runlevel pero que están diseñados para hacer que el sistema cambie de runlevel.</p>

  <h3>Los comandos init y telinit</h3>
  <p>Para especificar directamente el runlevel al que ir, usa <code>init</code> o <code>telinit</code>. El comando <code>telinit</code> en algunas distribuciones tiene una opción <code>-t</code>, que permite especificar un retardo de tiempo en segundos; de lo contrario, los comandos <code>init</code> y <code>telinit</code> son funcionalmente idénticos. De hecho, en algunos sistemas, el comando <code>telinit</code> puede ser simplemente un enlace al comando <code>init</code>.</p>

  <p>Para usar estos comandos, simplemente especifica el runlevel deseado como argumento. Por ejemplo, para reiniciar el sistema, usa el comando <code>init 6</code> o el comando <code>telinit 6</code>. O, para ir al runlevel 5, usa <code>init 5</code> o <code>telinit 5</code>.</p>

  <div class="important">
    <p><strong>Importante:</strong> Cambiar los runlevels afectará a las aplicaciones o servicios que estás ejecutando y puede causar pérdida de datos o interrupción de la conexión para los usuarios que acceden al sistema para esos servicios.</p>
  </div>

  <p>Con la sustitución de <code>init</code> por <strong>systemd</strong>, el comando <code>init</code> aún puede usarse para modificar el runlevel; systemd traducirá el runlevel deseado a un target. Por ejemplo, si se ejecuta <code>init 5</code>, systemd intentaría cambiar al estado <code>graphical.target</code>.</p>

  <p>Para que systemd cambie nativamente a un estado de target, con privilegios de root ejecuta:</p>

  <pre><code>systemctl isolate DESIRED.TARGET</code></pre>

  <p>Por ejemplo, para llevar el sistema al runlevel 1, ejecuta el comando <code>systemctl isolate rescue.target</code>. Del mismo modo, para ir nativamente al runlevel 5, ejecuta el comando <code>systemctl isolate graphical.target</code>.</p>

  <h3>Los comandos halt, poweroff, reboot y shutdown</h3>
  <p>Para llevar el sistema al runlevel cero, ejecuta el comando <code>halt</code>, <code>poweroff</code> o <code>shutdown</code>.</p>

  <p>Mientras que los comandos <code>halt</code> y <code>poweroff</code> comenzarán a apagar el sistema inmediatamente, el comando <code>shutdown</code> requiere un argumento de tiempo para indicar cuándo debe comenzar el apagado. Los formatos de este argumento de tiempo pueden ser la palabra <code>now</code>, un tiempo de cuenta regresiva en formato <code>HH:MM</code>, o el número de minutos a retrasar en formato <code>+M</code>. También se puede especificar un mensaje que aparecerá en las terminales de todos los usuarios con el comando <code>shutdown</code>. Por ejemplo:</p>

  <div class="note">
    <p><strong>Nota:</strong> El siguiente ejemplo puede no coincidir con la salida en nuestro entorno virtual.</p>
  </div>

  <pre><code>root@localhost:~# shutdown now "System going down for repairs"</code></pre>

  <p>El mensaje "System going down for repairs" (El sistema se está apagando para reparaciones) se mostraría en la ventana de la terminal de cada usuario que haya iniciado sesión actualmente.</p>

  <p>Curiosamente, si no se especifica una opción, el comando <code>shutdown</code> llevará el sistema al runlevel 1. El comando <code>shutdown</code> usado con la opción <code>-r</code> es similar a usar el comando <code>reboot</code> y hará que el sistema vaya al runlevel 6. El comando <code>shutdown</code> usado con la opción <code>-h</code> es similar a usar el comando <code>halt</code> y hará que el sistema vaya al runlevel 0.</p>

  <div class="consider-this">
    <h3>Considera esto</h3>
    <p>No siempre es necesario ir al runlevel 5 (en la mayoría de las distribuciones) para poder usar la Interfaz Gráfica de Usuario (GUI). La GUI, que generalmente es proporcionada por el software conocido como X Windows, también puede iniciarse con el comando <code>startx</code>.</p>

    <p>Después de usar el entorno gráfico, utiliza el cierre de sesión gráfico para finalizar la sesión de X Windows.</p>

    <p>El uso del comando <code>startx</code> no requiere privilegios de root como lo hacen los comandos <code>init 5</code> o <code>systemctl isolate graphical.target</code>.</p>
  </div>
  </section>
  <hr>

  <section id="18-5">
  <h2>18.5 El comando wall</h2>
  <p>A veces, el administrador del sistema necesita enviar mensajes a todos los usuarios sobre un evento pendiente. Aunque es posible enviar un mensaje utilizando el comando <code>shutdown</code>:</p>

  <pre><code>root@localhost:~# shutdown now "System going down for repairs"</code></pre>

  <p>Hay casos en los que la notificación puede no requerir el apagado inminente del sistema. Para esto se utiliza el comando <code>wall</code>. El comando <code>wall</code> puede usarse para mostrar un mensaje o el contenido de un archivo a todos los usuarios del sistema. Por ejemplo, el siguiente mensaje se está enviando al comando <code>wall</code> desde el comando <code>echo</code>:</p>

  <pre><code>root@localhost:~# exit
logout
sysadmin@localhost:~$ echo -e "El servidor estará fuera de línea el sábado\ndesde\n6:00PM hasta 12:00PM para mantenimiento programado" | wall
Broadcast message from sysadmin@localhost (console) (Wed May 29 22:13:59
2019):

El servidor estará fuera de línea el sábado desde
6:00PM hasta 12:00PM para mantenimiento programado</code></pre>

  <p>El comando <code>wall</code> acepta entrada estándar o el nombre de un archivo. Para mostrar un archivo, el comando <code>wall</code> requiere que el usuario tenga privilegios de root o que el contenido se envíe a través de otro comando, como el comando <code>cat</code>. Sin ninguna de estas opciones, el comando <code>wall</code> mostrará un mensaje de error:</p>

  <div class="note">
    <p><strong>Nota:</strong> El comando <code>sudo</code> requiere la contraseña de root <code>netlab123</code> en nuestro entorno virtual.</p>
  </div>

  <pre><code>sysadmin@localhost:~$ cd Documents
sysadmin@localhost:~/Documents$ wall letters.txt
wall: no leerá letters.txt - use stdin.
sysadmin@localhost:~/Documents$ sudo wall letters.txt
[sudo] password for sysadmin:

Broadcast message from sysadmin@localhost (console) (Wed May 29 22:15:23
2019):

a
b
c
d
e

sysadmin@localhost:~/Documents$ cat letters.txt | wall

Broadcast message from sysadmin@localhost (console) (Wed May 29 22:17:44
2019):

a
b
c
d
e</code></pre>

  <p>La opción <code>-n</code> puede ser utilizada por el comando <code>wall</code> para suprimir el encabezado inicial:</p>

  <pre><code>sysadmin@localhost:~/Documents$ sudo cat letters.txt | wall -n
wall: --nobanner solo está disponible para root

Broadcast message from sysadmin@localhost (console) (Wed May 29 22:18:24
2019):

a
b
c
d
e</code></pre>
  </section>
  <hr>

  <section id="18-6">
  <h2>18.6 Gestión de Servicios del Sistema</h2>
  <p>Como administrador de un sistema, es posible controlar qué servicios serán proporcionados por los diversos demonios (procesos que se ejecutan en segundo plano del sistema). Si deseas probar servicios o habilitarlos o deshabilitarlos temporalmente, podrías gestionarlos manualmente.</p>

  <p>Típicamente, los administradores querrán automatizar la gestión de servicios, de modo que cuando el sistema se lleve a un runlevel o estado objetivo específico, sabrán qué servicios deberían estar disponibles automáticamente.</p>

  <p>Si un sistema utiliza el proceso <strong>init tradicional</strong> para gestionar los servicios del sistema, entonces los scripts en el directorio <code>/etc/rc.d/init.d</code> se utilizan para gestionar el estado de esos servicios del sistema. Para mayor comodidad, este directorio generalmente tendrá un enlace simbólico desde el archivo <code>/etc/init.d</code>. Los scripts en este directorio a menudo se conocen como <strong>scripts de init</strong>.</p>

  <p>Para gestionar manualmente el estado de un servicio, como un servidor web, utiliza el script apropiado en el directorio <code>/etc/rc.d/init.d</code> para iniciar, detener o cambiar el estado del servidor web. Para gestionar un servicio con estos scripts, ejecuta el script con un argumento que especifique lo que el script debe hacer.</p>

  <p>Por ejemplo, en una distribución de Red Hat Enterprise Linux, el script para gestionar el servidor web tiene un nombre de ruta de <code>/etc/rc.d/init.d/httpd</code>. Así, para iniciar manualmente el servidor web, ejecutarías el siguiente comando como usuario root:</p>

  <div class="note">
    <p><strong>Nota:</strong> Los siguientes ejemplos representan un sistema diferente de la máquina virtual de este módulo. Los ejemplos pueden no coincidir con la salida en nuestro entorno virtual.</p>
  </div>

  <pre><code>[root@localhost ~]# /etc/rc.d/init.d/httpd start
Starting httpd:</code></pre>

  <p>Para detener manualmente un servidor web en funcionamiento, ejecuta:</p>

  <pre><code>[root@localhost ~]# /etc/rc.d/init.d/httpd stop
Stopping httpd:</code></pre>

  <p>En lugar de tener que escribir el nombre de ruta completo del script, muchos sistemas proporcionan un script de servicio que permite ejecutar el script de init sin tener que escribir la ruta completa al script; en su lugar, simplemente proporciona el nombre del programa init y la función que el script debe realizar como argumentos. Por ejemplo, para iniciar y detener el servidor web, usa:</p>

  <pre><code>[root@localhost ~]# service httpd start
[root@localhost ~]# service httpd stop</code></pre>

  <p>También es posible detener e iniciar el demonio del servidor web escribiendo:</p>

  <pre><code>[root@localhost ~]# service httpd restart</code></pre>

  <div class="consider-this">
    <h3>Considera esto</h3>
    <p>Si bien el comando <code>service</code> puede parecer más fácil que escribir el nombre de ruta completo, esto no siempre es así. La función de autocompletado del nombre del comando usando la tecla <kbd>Tab</kbd> a menudo puede hacer que escribir el nombre de ruta completo sea más rápido. Por ejemplo, <code>/etc/init.d/httpd stop</code> podría escribirse rápidamente usando la tecla <kbd>Tab</kbd>.</p>

    <p>Para el script <code>httpd</code>, esto podría considerarse un esfuerzo desperdiciado en comparación con simplemente usar el comando <code>service</code>. Pero considera una ruta como <code>/etc/init.d/blk-availability</code>; si se usa con el comando <code>service</code>, necesitas escribir completamente (y recordar el nombre exacto) <code>blk-availability</code>.</p>

    <p>Usar la ruta completa puede ser más fácil porque el shell puede autocompletar la mayor parte del nombre (si recuerdas con qué empieza).</p>
  </div>

  <p>Los diferentes scripts tienen diferentes capacidades o funciones que pueden realizar. Para descubrir lo que un script puede hacer, ejecuta el script sin ningún argumento. Por ejemplo:</p>

  <pre><code>[root@localhost ~]# /etc/init.d/httpd
Usage: httpd {start|stop|restart|condrestart|try-restart|force-reload|reload|status|fullstatus|graceful|help|configtest}</code></pre>

  <p>La siguiente tabla explica el propósito de estas funciones del script <code>httpd</code>, que muchos otros scripts también pueden implementar:</p>

  <table>
    <thead>
      <tr>
        <th>Argumento</th>
        <th>Función</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>start</code></td>
        <td>Si el servicio no está en ejecución, intenta iniciarlo.</td>
      </tr>
      <tr>
        <td><code>stop</code></td>
        <td>Si el servicio está en ejecución, intenta detenerlo.</td>
      </tr>
      <tr>
        <td><code>restart</code></td>
        <td>Detiene y luego reinicia el servicio. Si se realiza un cambio de configuración importante en un servicio, es posible que deba reiniciarse para que el cambio sea efectivo.</td>
      </tr>
      <tr>
        <td><code>condrestart</code></td>
        <td>Reinicia el servicio bajo la condición de que esté actualmente en ejecución.</td>
      </tr>
      <tr>
        <td><code>try-restart</code></td>
        <td>Igual que <code>condrestart</code>.</td>
      </tr>
      <tr>
        <td><code>reload</code></td>
        <td>Lee y carga la configuración del servicio. Recargar el archivo de configuración de un servicio es normalmente una forma menos disruptiva de hacer que los cambios de configuración sean efectivos, pero puede que no tenga éxito para cambios importantes.</td>
      </tr>
      <tr>
        <td><code>status</code></td>
        <td>Muestra si el servicio está detenido o el ID de proceso (PID) si el servicio está en ejecución. Nota: También es posible usar el comando <code>service --status-all</code> para ver el estado de todos los demonios.</td>
      </tr>
      <tr>
        <td><code>fullstatus</code></td>
        <td>Para el servidor web Apache, muestra la URL <code>/server-status</code>.</td>
      </tr>
      <tr>
        <td><code>graceful</code></td>
        <td>Para el servidor web Apache, reinicia el servidor de forma elegante. Si el servidor no está en ejecución, se inicia. A diferencia de un reinicio normal, las conexiones abiertas no se abortan.</td>
      </tr>
      <tr>
        <td><code>help</code></td>
        <td>Muestra el uso del script.</td>
      </tr>
      <tr>
        <td><code>configtest</code></td>
        <td>Comprueba la corrección de los archivos de configuración. Para algunos servicios, si el archivo de configuración se modifica, esto puede usarse para verificar que los cambios no tienen errores de sintaxis.</td>
      </tr>
    </tbody>
  </table>
  </section>
  <hr>

  <section id="18-7">
  <h2>18.7 Directorios de Runlevel</h2>
  <p>Aunque es posible iniciar servicios manualmente, la mayoría de los servicios son iniciados automáticamente por el proceso init que utilice el sistema.</p>

  <p>Con el proceso <strong>init tradicional</strong>, se utilizan directorios específicos para gestionar qué servicios se iniciarán o detendrán automáticamente en diferentes runlevels. En muchas distribuciones de Linux, estos directorios existen dentro del directorio <code>/etc</code> y tienen los siguientes nombres de ruta:</p>

  <ul>
    <li><code>rc0.d</code></li>
    <li><code>rc1.d</code></li>
    <li><code>rc2.d</code></li>
    <li><code>rc3.d</code></li>
    <li><code>rc4.d</code></li>
    <li><code>rc5.d</code></li>
    <li><code>rc6.d</code></li>
  </ul>

  <p>El número en el nombre del directorio representa el runlevel que gestiona; por ejemplo, <code>rc0.d</code> es para el runlevel 0 y <code>rc1.d</code> es para el runlevel 1. Para demostrarlo, los directorios que se utilizan para gestionar qué servicios se iniciarán o detendrán automáticamente en diferentes runlevels en nuestra MV se pueden encontrar en el directorio <code>/etc</code>. Para mostrar estos directorios, ejecuta el siguiente comando:</p>

  <pre><code>sysadmin@localhost:~$ cd /etc
sysadmin@localhost:/etc$ ls -d rc*
rc0.d  rc1.d  rc2.d  rc3.d  rc4.d  rc5.d  rc6.d  rcS.d</code></pre>

  <p>Para que un servicio se inicie en un runlevel, se puede crear un enlace simbólico al script de init en el directorio <code>/etc/rc.d/init.d</code> dentro del directorio del runlevel apropiado. El nombre de este enlace debe comenzar con la letra <code>S</code>, seguido de un número del uno al noventa y nueve, y el nombre del script de init al que está vinculado.</p>

  <pre><code>sysadmin@localhost:/etc$ cd rc2.d
sysadmin@localhost:/etc/rc2.d$ ls
S01bind9             S01cron  S01irqbalance  S01rsync    S01ssh
S01console-setup.sh  S01dbus  S01plymouth    S01rsyslog  S01uuidd
sysadmin@localhost:/etc/rc2.d$ cd</code></pre>

  <p>Por ejemplo, cuando el servidor web está configurado para iniciarse en un sistema Linux en el runlevel 5, hay un enlace simbólico en el directorio <code>/etc/rc.d/rc5.d</code> llamado <code>S85httpd</code> que está vinculado al script <code>/etc/rc.d/init.d/httpd</code>:</p>

  <div class="note">
    <p><strong>Nota:</strong> Los siguientes ejemplos representan un sistema diferente de la máquina virtual de este módulo. Los ejemplos pueden no coincidir con la salida en nuestro entorno virtual.</p>
  </div>

  <pre><code>[root@localhost ~]# ls -l /etc/rc.d/rc5.d/S85httpd
lrwxrwxrwx 1 root root 19 Jun 27 16:53 /etc/rc.d/rc5.d/S85httpd ->
../init.d/httpd</code></pre>

  <p>Para crear este enlace manualmente, ejecutarías el siguiente comando:</p>

  <pre><code>[root@localhost ~]# ln -s /etc/rc.d/init.d/httpd /etc/rc.d/rc5.d/S85httpd</code></pre>

  <p>Así como los enlaces de archivo que empiezan con <code>S</code> en un directorio de runlevel indicarán que un servicio debe iniciarse, los enlaces de archivo que empiezan con <code>K</code> en un directorio de runlevel indicarán que un servicio debe detenerse (terminarse).</p>

  <p>Usando el servidor web como ejemplo nuevamente; para que el servidor web se detenga en el runlevel 5, crea un enlace simbólico en el directorio <code>/etc/rc.d/rc5.d</code> que comenzaría con la letra <code>K</code>, seguido de un número del uno al noventa y nueve, y el nombre del script de init al que está vinculado:</p>

  <pre><code>[root@localhost ~]# ls -l /etc/rc.d/rc5.d/K15httpd
lrwxrwxrwx 1 root root 19 Jun 27 16:53 /etc/rc.d/rc5.d/K15httpd -> ../init.d/httpd</code></pre>

  <p>Si el enlace se creó manualmente, el enlace de inicio tendría que eliminarse antes de que se pudiera crear el enlace de detención:</p>

  <pre><code>[root@localhost ~]# rm /etc/rc.d/rc5.d/S85httpd
[root@localhost ~]# ln -s /etc/rc.d/init.d/httpd /etc/rc.d/rc5.d/K15httpd</code></pre>

  <div class="consider-this">
    <h3>Considera esto</h3>
    <p>Los scripts <code>K</code> a veces confunden a los administradores principiantes. A menudo se preguntan: "¿Por qué debería detener un servicio cuando el sistema se lleva a un runlevel?" Esta confusión típicamente surge de la idea de que los runlevels son solo una "cosa de arranque", pero como se mencionó anteriormente, un administrador puede cambiar el sistema de un runlevel a otro.</p>

    <p>Imagina que el servicio <code>httpd</code> está disponible en el runlevel 5, pero no en el runlevel 3. Cuando el sistema pasa del runlevel 5 al runlevel 3, el servicio <code>httpd</code> debe detenerse. De ahí los scripts <code>K</code>.</p>

    <p>Pero, ¿qué pasa si el servicio no se está ejecutando cuando se llama al script <code>K</code>? En ese caso, el script <code>K</code> está escrito de tal manera que se da cuenta de esto y no hace nada.</p>

    <p>La razón por la que tanto los enlaces de inicio como los de detención tienen un número después de la letra <code>S</code> o <code>K</code> es para asegurar que los servicios se inicien o detengan en la secuencia correcta. Los scripts se inician (o detienen) en orden, por lo que <code>K15httpd</code> se ejecutaría antes que <code>K35vncserver</code>.</p>

    <p>Si los servicios no se inician o detienen en el orden correcto, es posible que no funcionen correctamente porque algunos servicios dependen de otros servicios para funcionar. Por ejemplo, para que un servidor web funcione como debería, el servicio de red ya debe estar en ejecución. Darle al servicio de red un número de inicio más bajo que al servidor web significa que init iniciará el servicio de red antes de intentar iniciar el servicio web.</p>

    <p>Entonces, ¿qué número se supone que debe proporcionarse a un script específico para <code>S</code> y <code>K</code>? Mira el script mismo para la línea que contiene <code>chkconfig</code>:</p>

    <pre><code>[root@localhost ~]# grep chkconfig /etc/init.d/httpd
# chkconfig: - 85 15</code></pre>

    <p>El penúltimo número <code>85</code> de la línea <code>chkconfig</code> es el número <code>S</code> que se debe colocar en este script; el último número <code>15</code> es el número <code>K</code>.</p>

    <p>En realidad, los días de tener que gestionar manualmente los enlaces simbólicos en los diferentes directorios de runlevel han quedado atrás. Hoy en día existen numerosas herramientas de línea de comandos y gráficas para gestionar estos enlaces simbólicos.</p>
  </div>
  </section>
  <hr>

  <section id="18-8">
  <h2>18.8 El comando chkconfig</h2>
  <p>El comando <code>chkconfig</code> puede utilizarse para ver qué servicios se iniciarán en diferentes runlevels. Este comando también se puede usar para activar o desactivar un servicio para runlevels específicos. En las distribuciones de Linux que no derivan de Red Hat, es posible que esta herramienta no esté disponible.</p>

  <p>Para ver todos los servicios que están configurados para iniciarse o detenerse automáticamente, el administrador puede ejecutar el comando <code>chkconfig --list</code> y la salida se vería algo así (aunque habría muchas más líneas de salida):</p>

  <div class="note">
    <p><strong>Nota:</strong> Los siguientes ejemplos representan un sistema diferente de la máquina virtual de este módulo. Los ejemplos pueden no coincidir con la salida en nuestro entorno virtual.</p>
  </div>

  <pre><code>[root@localhost ~]# chkconfig --list
auditd          0:off   1:off   2:on    3:on    4:on    5:on    6:off
crond           0:off   1:off   2:on    3:on    4:on    5:on    6:off
httpd           0:off   1:off   2:off   3:off   4:off   5:off   6:off
iptables        0:off   1:off   2:on    3:on    4:on    5:on    6:off
netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off
netfs           0:off   1:off   2:off   3:on    4:on    5:on    6:off
network         0:off   1:off   2:on    3:on    4:on    5:on    6:off
quota_nld       0:off   1:off   2:off   3:off   4:off   5:off   6:off
rdisc           0:off   1:off   2:off   3:off   4:off   5:off   6:off
restorecond     0:off   1:off   2:off   3:off   4:off   5:off   6:off
rsyslog         0:off   1:off   2:on    3:on    4:on    5:on    6:off
saslauthd       0:off   1:off   2:off   3:off   4:off   5:off   6:off
sendmail        0:off   1:off   2:on    3:on    4:on    5:on    6:off
sshd            0:off   1:off   2:on    3:on    4:on    5:on    6:off
udev-post       0:off   1:on    2:on    3:on    4:on    5:on    6:off</code></pre>

  <p>La salida de cada línea muestra el nombre del archivo de script encontrado en el directorio <code>/etc/rc.d/init.d</code>, seguido de cada número de runlevel, dos puntos, y si el servicio está configurado como activado (<code>on</code>) o desactivado (<code>off</code>). Por ejemplo, basándose en la salida del gráfico anterior, el servicio <code>auditd</code> se inicia en los runlevels 2, 3, 4 y 5.</p>

  <p>Para ver la configuración de un solo servicio, usa el comando <code>chkconfig --list SCRIPT</code> donde <code>SCRIPT</code> es el nombre de un archivo de script encontrado en el directorio <code>/etc/rc.d/init.d</code>. Por ejemplo, para ver el script del servidor web, ejecuta:</p>

  <pre><code>[root@localhost ~]# chkconfig --list httpd
httpd            0:off   1:off   2:off    3:off    4:off    5:off    6:off</code></pre>

  <p>Para habilitar el servicio para que se inicie en la mayoría de los runlevels, usa el comando <code>chkconfig SERVICE on</code>, donde <code>SERVICE</code> es el nombre de un archivo de script encontrado en el directorio <code>/etc/rc.d/init.d</code>. Así, para habilitar el servidor web para que se inicie en la mayoría de los runlevels, ejecuta el comando <code>chkconfig httpd on</code>:</p>

  <pre><code>[root@localhost ~]# chkconfig httpd on
[root@localhost ~]# chkconfig --list httpd
httpd            0:off   1:off   2:on    3:on    4:on    5:on    6:off</code></pre>

  <p>Para la mayoría de los servicios, si el comando <code>chkconfig</code> se usa para habilitar el servicio, este se iniciará automáticamente en los runlevels 2 a 5 y se detendrá automáticamente en los runlevels 0, 1 y 6. Esto puede variar ligeramente según el contenido del propio script.</p>

  <p>En el script <code>/etc/rc.d/init.d/httpd</code>, hay una línea que contiene lo siguiente:</p>

  <pre><code>[root@localhost ~]# chkconfig: - 85 15</code></pre>

  <p>El <code>-</code> indica que el servicio no se habilita en ningún runlevel automáticamente cuando se añade por primera vez a la gestión de chkconfig. En otras palabras, este servicio no está configurado para iniciarse automáticamente a menos que un administrador use el comando <code>chkconfig httpd on</code>.</p>

  <p>Algunos scripts tienen un valor de <code>chkconfig</code> diferente; por ejemplo, el script <code>etc/rc.d/init.d/atd</code> tiene la siguiente línea:</p>

  <pre><code>[root@localhost ~]# chkconfig:   345 95 5</code></pre>

  <p>El <code>345</code> significa que <code>atd</code> está habilitado por defecto en los runlevels 3, 4 y 5.</p>

  <p>Para activar o desactivar servicios para un nivel no predeterminado, se puede usar la opción <code>--level</code> con el comando <code>chkconfig</code>. Por ejemplo, los siguientes dos comandos asegurarían que el servicio <code>atd</code> estuviera disponible en los runlevels 2 y 4, pero no disponible en los runlevels 3 y 5:</p>

  <pre><code>[root@localhost ~]# chkconfig --level 24 atd on
[root@localhost ~]# chkconfig --level 35 atd off</code></pre>

  <p>También deben mencionarse otras dos opciones de <code>chkconfig</code>, aunque rara vez se usan directamente. Las opciones <code>chkconfig --add</code> y <code>--del</code> pueden usarse manualmente, pero normalmente se usan automáticamente cuando un administrador instala un nuevo paquete de software de servicio o elimina un paquete de software de servicio.</p>

  <p>Si un administrador creara un script de init llamado <code>serviced</code> y lo almacenara en el directorio <code>/etc/rc.d/init.d</code>, el comando <code>chkconfig --add SERVICE</code> necesitaría ejecutarse primero antes de usar los comandos <code>chkconfig SERVICE on</code> o <code>chkconfig SERVICE off</code>. Un comando similar a este se ejecuta cuando se instala un nuevo paquete de software que contiene un servicio.</p>

  <p>El comando <code>chkconfig --del SERVICE</code> eliminaría cualquier enlace en los directorios de runlevel y los servicios no se iniciarían ni detendrían automáticamente en ningún runlevel. Un comando similar a este se ejecuta cuando se elimina un paquete de software existente para un servicio.</p>
  </section>
  <hr>

  <section id="18-9">
  <h2>18.9 El directorio /etc/init</h2>
  <p>Para los usuarios de distribuciones de Linux derivadas de Debian, el directorio <code>/etc/init</code> se utiliza para almacenar los scripts de <strong>Upstart</strong>. Estos scripts iniciarán o detendrán diferentes servicios basándose en diferentes eventos, incluyendo el paso a un runlevel específico.</p>

  <p>Para Debian y sus derivados (como Ubuntu), hay que saber que los runlevels utilizados varían ligeramente de los definidos por la <strong>Linux Standard Base 4.1</strong>. Los runlevels 0, 1 y 6 son los mismos que los estándar. Sin embargo, el runlevel 2 se considera el runlevel predeterminado; este runlevel está configurado para múltiples usuarios con la GUI en funcionamiento, muy parecido al runlevel cinco estándar. Los runlevels 3, 4 y 5 son inicialmente iguales al runlevel 2.</p>

  <p>Si un administrador quiere cambiar los runlevels de un servicio, el archivo de configuración de ese servicio puede modificarse en el directorio <code>/etc/init</code>. Por ejemplo, en una instalación de Ubuntu que incluye el servidor web Apache, este directorio normalmente contiene el archivo de configuración de Upstart <code>/etc/init/apache2.conf</code>. Dentro del archivo <code>/etc/init/apache2.conf</code> deberían haber dos líneas que definen los runlevels para iniciar y detener el servidor:</p>

  <pre><code>start on runlevel [2345]
stop on runlevel [!2345]</code></pre>

  <p>En este caso, el servicio se iniciaría en los runlevels del 2 al 5 y se detendría en los runlevels que no son del 2 al 5 porque el carácter <code>!</code> indica "no estos". Para cambiar el servicio para que solo esté disponible en los runlevels 2 y 3, cambia las líneas para que sean como las siguientes:</p>

  <pre><code>start on runlevel [23]
stop on runlevel [!23]</code></pre>

  <p>Para deshabilitar un servicio sin desinstalarlo, se puede crear un archivo de anulación (override file) en el directorio <code>/etc/init</code>. Este archivo debe tener el mismo nombre que el archivo de configuración del servicio, pero terminando en <code>.override</code> en lugar de <code>.conf</code>. Esta es la técnica preferida en lugar de comentar las líneas "start on".</p>

  <p>El contenido del archivo <code>.override</code> debe ser simplemente la palabra <code>manual</code>, lo que significa que el servicio ignorará cualquier línea "start on" del archivo de configuración. Por ejemplo, para anular el archivo de configuración de <code>apache2</code> y deshabilitar el servidor web, ejecuta el siguiente comando:</p>

  <pre><code>[sysadmin@localhost ~]$ sudo 'echo manual > /etc/init/apache2.override'</code></pre>
  </section>
  <hr>

  <section id="18-10">
  <h2>18.10 El comando systemctl</h2>
  <p>El comando <code>systemctl</code> se utiliza en sistemas que tienen <strong>systemd</strong> como reemplazo del proceso init tradicional. Este único comando puede usarse para controlar manualmente el estado de los servicios, habilitar o deshabilitar el inicio automático de servicios, así como cambiar los targets del sistema.</p>

  <p>El comando <code>systemctl</code> busca en el directorio <code>/usr/lib/systemd</code> información sobre qué enlace simbólico habilita un servicio específico. Este directorio es donde se colocan originalmente los archivos de un servicio cuando se instala.</p>

  <p>También es posible editar archivos de servicio para modificar el servicio; sin embargo, estos cambios deben hacerse en los archivos de servicio encontrados en el directorio <code>/etc/systemd</code> en su lugar.</p>

  <p>Para controlar manualmente el estado de un servicio, usa el comando <code>systemctl</code> para iniciar, detener o verificar el estado de ese servicio. Por ejemplo, para iniciar un servicio como el servidor web, ejecuta lo siguiente:</p>

  <pre><code>systemctl start httpd.service</code></pre>

  <p>Para apagar el servicio:</p>

  <pre><code>systemctl stop httpd.service</code></pre>

  <p>Para verificar el estado del servicio:</p>

  <pre><code>systemctl status httpd.service</code></pre>

  <p>Para ver el estado de todos los servicios:</p>

  <pre><code>systemctl -a
systemctl --all</code></pre>

  <p>Para configurar un servicio para que se inicie automáticamente, ejecuta lo siguiente:</p>

  <pre><code>systemctl enable httpd.service</code></pre>

  <p>Para configurar un servicio para que no se inicie automáticamente, ejecuta lo siguiente:</p>

  <pre><code>systemctl disable httpd.service</code></pre>

  <p>Como se mencionó anteriormente, es posible cambiar a un runlevel diferente con el comando <code>systemctl</code>:</p>

  <pre><code>systemctl isolate DESIRED.TARGET</code></pre>

  <p>El comando <code>systemctl</code> también puede gestionar los estados de baja o nula energía del sistema con líneas de comando como:</p>

  <pre><code>systemctl hibernate
systemctl suspend
systemctl poweroff
systemctl reboot</code></pre>

  <p>Al habilitar un servicio con systemd ejecutando un comando como el siguiente, se crea un enlace simbólico dentro del nivel objetivo que "quiere" que ese servicio esté en funcionamiento:</p>

  <pre><code>[root@localhost ~]# systemctl enable named.service</code></pre>

  <p>En este ejemplo, el comando <code>systemctl</code> anterior ejecuta el siguiente comando:</p>

  <pre><code>[root@localhost ~]# ln -s /usr/lib/systemd/system/named.service \
/etc/systemd/system/mulit-user.target.wants/named.service</code></pre>

  <p>La razón por la que <code>multi-user.target</code> quiere que <code>named.service</code> esté en ejecución se basa en una línea dentro del archivo <code>named.service</code> que contiene lo siguiente:</p>

  <pre><code>WantedBy=multi-user.target</code></pre>

  <p>En esencia, esta línea establece el único target que normalmente iniciará este servicio automáticamente. Si el administrador modifica el target al que está configurado <code>WantedBy</code>, entonces la próxima vez que se habilite ese servicio, el enlace simbólico que habilita el servicio se hará al nuevo target que quiere el servicio.</p>

  <p>Por ejemplo, si la línea para <code>named.service</code> en el archivo <code>/usr/lib/systemd/system/named.service</code> se actualiza para ser lo siguiente:</p>

  <pre><code>WantedBy=graphical.target</code></pre>

  <p>Entonces, después de ejecutar los comandos <code>systemctl disable named.service</code> y <code>systemctl enable named.service</code>, el enlace para iniciar el servicio <code>named</code> se crea en el directorio <code>/etc/systemd/system/graphical.target.wants</code> y el servicio se iniciará cuando el sistema vaya a <code>graphical.target</code> en lugar de <code>multi-user.target</code>.</p>

  <p>Similar al comando <code>chkconfig --list</code>, todos los servicios que deben habilitarse para un target específico dentro de systemd se pueden ver utilizando un comando <code>systemctl list-dependencies</code> para ese target, como:</p>

  <pre><code>[root@localhost ~]# systemctl list-dependencies graphical.target</code></pre>

  <p>La salida parcial a continuación muestra cada nivel de servicios deseados debajo de un target y las dependencias entre cada target indentadas. Se ven servicios como <code>atieventsd.service</code> y <code>gdm.service</code> son deseados por el <code>graphical.target</code>.</p>

  <p>Además, el <code>graphical.target</code> depende del <code>multi-user.target</code> y el <code>multi-user.target</code> quiere los servicios <code>abrt-ccpp.service</code> y <code>abrt-oops.service</code>.</p>

  <p>La salida real muestra muchos más servicios y targets.</p>

  <pre><code>[root@localhost ~]# systemctl list-dependencies graphical.target
graphical.target
├─atieventsd.service
├─gdm.service
├─jexec.service
├─systemd-readahead-collect.service
├─systemd-readahead-replay.service
├─systemd-update-utmp-runlevel.service
 ├─abrt-ccps.service
 ├─abrt-oops.service</code></pre>

  <div class="consider-this">
    <h3>Considera esto</h3>
    <p>Debido a que existen tres tipos diferentes de sistemas de arranque (init tradicional, Upstart y systemd), la pregunta lógica es: "¿Cuál usa mi sistema?" La respuesta fácil a esta pregunta es verificar la existencia de dos directorios: <code>/etc/init</code> y <code>/etc/systemd</code>.</p>

    <p>Si tu sistema tiene un directorio <code>/etc/init</code>, entonces tu sistema está usando Upstart. Si tu sistema tiene un directorio <code>/etc/systemd</code>, entonces tu sistema está usando systemd. De lo contrario, tu sistema está usando init tradicional.</p>
  </div>
  </section>
  <hr>

  <section id="18-11">
  <h2>18.11 Boot Target</h2>
  <p>Muchos sistemas modernos utilizan <strong>systemd</strong> en lugar de init para establecer los targets de arranque. La siguiente tabla muestra los equivalentes de runlevel para los targets de arranque.</p>

  <table>
    <thead>
      <tr>
        <th>Runlevel</th>
        <th>Propósito</th>
        <th>systemd Target</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0</td>
        <td>Detener o apagar el sistema</td>
        <td>poweroff.target</td>
      </tr>
      <tr>
        <td>1</td>
        <td>Modo monousuario para tareas administrativas</td>
        <td>rescue.target</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Modo multiusuario sin interfaces de red configuradas o servicios de red</td>
        <td>multi-user.target</td>
      </tr>
      <tr>
        <td>3</td>
        <td>Arranque normal del sistema</td>
        <td>multi-user.target</td>
      </tr>
      <tr>
        <td>4</td>
        <td>Definible por el usuario</td>
        <td>multi-user.target</td>
      </tr>
      <tr>
        <td>5</td>
        <td>Iniciar el sistema normalmente con un gestor de pantalla gráfico</td>
        <td>graphical.target</td>
      </tr>
      <tr>
        <td>6</td>
        <td>Reiniciar el sistema</td>
        <td>reboot.target</td>
      </tr>
    </tbody>
  </table>

  <p>Para verificar el runlevel actual en un sistema Linux, lista el archivo <code>/etc/systemd/system/default.target</code> usando el comando <code>ls -l</code>:</p>

  <div class="note">
    <p><strong>Nota:</strong> Los siguientes ejemplos representan un sistema diferente de la máquina virtual de este módulo. Los ejemplos pueden no coincidir con la salida en nuestro entorno virtual.</p>
  </div>

  <pre><code>[sysadmin@localhost ~]$ su - root
Password:
[root@localhost ~]# ls -l /etc/systemd/system/default.target
lrwxrwxrwx 1 root root 37 Dec  4 14:39 /etc/systemd/system/default.target ->/lib/systemd/system/multi-user.target</code></pre>

  <p>Si necesitas configurar el sistema para que arranque en modo monousuario para tareas de resolución de problemas o recuperación, usa el comando <code>systemctl enable rescue.target</code>, seguido del comando <code>systemctl set-default rescue.target</code>:</p>

  <pre><code>[root@localhost ~]# systemctl enable rescue.target
Created symlink /etc/systemd/system/kbrequest.target, pointing to
/usr/lib/systemd/system/rescue.target.
[root@localhost ~]# systemctl set-default rescue.target
Removed /etc/systemd/system/default.target.
Created symlink /etc/systemd/system/default.target, pointing to /usr/lib/systemd/system/rescue.target.</code></pre>

  <p>Para cambiar el sistema a modo gráfico después del arranque, usa el comando <code>systemctl isolate graphical.target</code>:</p>

  <pre><code>[root@localhost ~]# systemctl isolate graphical.target
Failed to get D-Bus connection: Operation not permitted</code></pre>
  </section>
  <hr>
  <section id="18-12">
  <h2>18.12 acpid</h2>
  <p>Los sistemas Linux utilizan el demonio de eventos ACPI (Advanced Configuration and Power Interface) <strong>acpid</strong> para notificar a los programas del espacio de usuario sobre eventos ACPI. El ACPI permite al kernel configurar componentes de hardware y gestionar la configuración de energía del sistema, como la supervisión del estado de la batería, la temperatura y más.</p>

  <p>Un ejemplo del uso de <code>acpid</code> para la gestión de energía sería que el sistema se apagara después de que el usuario presione el botón de encendido. En los sistemas modernos, <code>acpid</code> normalmente se inicia como un proceso en segundo plano durante el arranque y abre un archivo de eventos en el directorio <code>/proc/acpi</code>. Por ejemplo, el archivo <code>wakeup</code> en el directorio <code>/proc/acpi</code> a continuación muestra la siguiente información:</p>

  <pre><code>sysadmin@localhost:~$ su -
Password:
root@localhost:~# ls -l /proc/acpi
total 0
-rw-r--r-- 1 root root 0 May 28 21:09 wakeup
root@localhost:~# cat /proc/acpi/wakeup
Device  S-state   Status   Sysfs node
PCI0      S5    *disabled  no-bus:pci0000:00
root@localhost:~#</code></pre>

  <p>Cuando el kernel envía un evento ACPI, <code>acpid</code> determinará los siguientes pasos basándose en las reglas definidas en los archivos de configuración del directorio <code>/etc/acpi</code>. Los administradores pueden crear scripts de reglas en el directorio <code>/etc/acpi</code> para controlar las acciones tomadas por el sistema.</p>

  <p>El comando <code>acpi</code> se utiliza para mostrar información sobre la configuración ACPI del hardware del sistema. No está instalado en nuestra MV, pero el ejemplo anterior muestra un script <code>acpi</code> básico en el directorio <code>/proc/acpi</code> que controla el despertar de la máquina después de ser suspendida. Hay muchas opciones disponibles para el comando <code>acpi</code> para mostrar diversa información para la gestión de energía. La tabla a continuación resume algunas de las opciones disponibles para el comando <code>acpi</code>:</p>

  <table>
    <thead>
      <tr>
        <th>Opción</th>
        <th>Propósito</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>-b</code><br><code>--battery</code></td>
        <td>Muestra información de la batería</td>
      </tr>
      <tr>
        <td><code>-a</code><br><code>--ac-adapter</code></td>
        <td>Muestra información del adaptador de CA</td>
      </tr>
      <tr>
        <td><code>-t</code><br><code>--thermal</code></td>
        <td>Muestra información térmica</td>
      </tr>
      <tr>
        <td><code>-c</code><br><code>--cooling</code></td>
        <td>Muestra información del dispositivo de enfriamiento</td>
      </tr>
      <tr>
        <td><code>-s</code><br><code>--show-empty</code></td>
        <td>Muestra dispositivos no operativos</td>
      </tr>
      <tr>
        <td><code>-f</code><br><code>--fahrenheit</code></td>
        <td>Utiliza Fahrenheit como unidad de temperatura en lugar del predeterminado, Celsius</td>
      </tr>
      <tr>
        <td><code>-i</code><br><code>--details</code></td>
        <td>Muestra detalles adicionales si están disponibles; capacidad de la batería y puntos de activación de temperatura</td>
      </tr>
    </tbody>
  </table>

  <div class="note">
    <p><strong>Nota:</strong> El comando <code>acpi</code> no existe en nuestro entorno virtual</p>
  </div>
  </section>
  <hr>
  
  <hr>
  <div class="volver">
    <a href="../index.html">← Volver al índice</a>
  </div>

</body>
</html>
